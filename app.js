import { 
    onAuthStateChangedListener, 
    signInUser, 
    signUpUser, 
    signOutUser,
    onAccountsUpdate,
    onTransactionsUpdate,
    onFixedBillsUpdate,
    addTransaction,
    performTransfer,
    addAccount,
    addFixedBill,
    updateAccount,
    updateFixedBill,
    deleteAccount,
    deleteFixedBill,
    deleteAllTransactions,
    addDebt,
    queryDebts,
    refundTransaction,
    payFixedBill,
    getFixedBillStatus,
    getFixedBillsWithStatus,
    markFixedBillAsPaid,
    loadOlderTransactions,
    loadTransactionsWithPagination,
    getFixedBillInfo,
    getFixedBillInfoOptimized,
    checkAndExpandPeriods,
    getMonthPaymentStatus,
    getFixedBillPaymentHistoryOptimized,
    getMultipleMonthsStatusOptimized,
    analyzeMonthlyComparison,
    generateSavingsSuggestions,
    saveCustomUserName,
    loadCustomUserName
} from './src/firestoreService.js';
import { db, auth } from './firebase-config.js';
import { 
    collection, 
    query, 
    where, 
    getDocs,
    doc,
    getDoc
} from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
import { processMessageWithGemini, updateGeminiContext } from './src/gemini-service.js';

// ========================================
// ðŸ”§ FUNÃ‡Ã•ES AUXILIARES PARA CONTAS FIXAS
// ========================================

// FunÃ§Ã£o para obter perÃ­odo (YYYY-MM) de uma data
function getPeriodFromDate(date) {
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    return `${year}-${month}`;
}

// FunÃ§Ã£o para calcular todos os perÃ­odos desde a data inicial
function calculateAllPeriodsFromInitial(initialDate, dueDay, monthsCount = 12, autoExpand = true) {
    const periods = [];
    const startYear = initialDate.getFullYear();
    const startMonth = initialDate.getMonth() + 1;
    
    const maxMonths = autoExpand ? monthsCount : monthsCount;
    
    for (let i = 0; i < maxMonths; i++) {
        const targetMonth = startMonth + i;
        const targetYear = targetMonth > 12 ? startYear + Math.floor((targetMonth - 1) / 12) : startYear;
        const adjustedMonth = targetMonth > 12 ? ((targetMonth - 1) % 12) + 1 : targetMonth;
        
        const period = `${targetYear}-${adjustedMonth.toString().padStart(2, '0')}`;
        periods.push({
            period,
            year: targetYear,
            month: adjustedMonth,
            monthName: new Date(targetYear, adjustedMonth - 1).toLocaleDateString('pt-BR', { month: 'long' }),
            dueDate: new Date(targetYear, adjustedMonth - 1, dueDay),
            isAutoGenerated: i >= 12
        });
    }
    
    return periods;
}

// ========================================
// ðŸŽ¨ SISTEMA DE MODAIS BONITOS
// ========================================

// FunÃ§Ã£o para mostrar modal de notificaÃ§Ã£o (substitui alert)
function showNotificationModal(title, message, icon = 'â„¹ï¸') {
    return new Promise((resolve) => {
        const modal = document.getElementById('notification-modal');
        const titleEl = document.getElementById('notification-title');
        const messageEl = document.getElementById('notification-message');
        const iconEl = document.getElementById('notification-icon');
        const okBtn = document.getElementById('notification-ok-btn');
        
        titleEl.textContent = title;
        messageEl.textContent = message;
        iconEl.textContent = icon;
        
        // Remover listeners anteriores
        const newOkBtn = okBtn.cloneNode(true);
        okBtn.parentNode.replaceChild(newOkBtn, okBtn);
        
        newOkBtn.addEventListener('click', () => {
            hideModal(modal);
            resolve(true);
        });
        
        // Fechar ao clicar fora
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                hideModal(modal);
                resolve(true);
            }
        });
        
        showModal(modal);
    });
}

// FunÃ§Ã£o para mostrar modal de confirmaÃ§Ã£o (substitui confirm)
function showConfirmationModal(title, message, icon = 'â“') {
    return new Promise((resolve) => {
        const modal = document.getElementById('confirmation-modal');
        const titleEl = document.getElementById('confirmation-title');
        const messageEl = document.getElementById('confirmation-message');
        const iconEl = document.getElementById('confirmation-icon');
        const cancelBtn = document.getElementById('confirmation-cancel-btn');
        const confirmBtn = document.getElementById('confirmation-confirm-btn');
        
        titleEl.textContent = title;
        messageEl.textContent = message;
        iconEl.textContent = icon;
        
        // Remover listeners anteriores
        const newCancelBtn = cancelBtn.cloneNode(true);
        const newConfirmBtn = confirmBtn.cloneNode(true);
        cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        
        newCancelBtn.addEventListener('click', () => {
            hideModal(modal);
            resolve(false);
        });
        
        newConfirmBtn.addEventListener('click', () => {
            hideModal(modal);
            resolve(true);
        });
        
        // Fechar ao clicar fora
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                hideModal(modal);
                resolve(false);
            }
        });
        
        showModal(modal);
    });
}

// FunÃ§Ã£o para mostrar modal de sucesso
function showSuccessModal(message) {
    return new Promise((resolve) => {
        const modal = document.getElementById('success-modal');
        const messageEl = document.getElementById('success-message');
        const okBtn = document.getElementById('success-ok-btn');
        
        messageEl.textContent = message;
        
        // Remover listeners anteriores
        const newOkBtn = okBtn.cloneNode(true);
        okBtn.parentNode.replaceChild(newOkBtn, okBtn);
        
        newOkBtn.addEventListener('click', () => {
            hideModal(modal);
            resolve(true);
        });
        
        // Fechar ao clicar fora
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                hideModal(modal);
                resolve(true);
            }
        });
        
        showModal(modal);
    });
}

// FunÃ§Ã£o para mostrar modal de erro
function showErrorModal(message) {
    return new Promise((resolve) => {
        const modal = document.getElementById('error-modal');
        const messageEl = document.getElementById('error-message');
        const okBtn = document.getElementById('error-ok-btn');
        
        messageEl.textContent = message;
        
        // Remover listeners anteriores
        const newOkBtn = okBtn.cloneNode(true);
        okBtn.parentNode.replaceChild(newOkBtn, okBtn);
        
        newOkBtn.addEventListener('click', () => {
            hideModal(modal);
            resolve(true);
        });
        
        // Fechar ao clicar fora
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                hideModal(modal);
                resolve(true);
            }
        });
        
        showModal(modal);
    });
}

// FunÃ§Ã£o para mostrar modal de aviso
function showWarningModal(message) {
    return showNotificationModal('AtenÃ§Ã£o', message, 'âš ï¸');
}

// FunÃ§Ã£o para mostrar modal de informaÃ§Ã£o
function showInfoModal(message) {
    return showNotificationModal('InformaÃ§Ã£o', message, 'â„¹ï¸');
}

// ========================================
// ðŸ”„ SUBSTITUIÃ‡Ã•ES DOS ALERTS E CONFIRMS
// ========================================

// Substituir alert() por showNotificationModal()
function alert(message) {
    return showNotificationModal('NotificaÃ§Ã£o', message, 'â„¹ï¸');
}

// Substituir confirm() por showConfirmationModal()
function confirm(message) {
    return showConfirmationModal('Confirmar', message, 'â“');
}

// Estado da aplicaÃ§Ã£o
let currentUser = null;
let accounts = [];
let transactions = [];
let fixedBills = [];
let customUserName = null; // Nome personalizado do usuÃ¡rio

// Estado de paginaÃ§Ã£o otimizada para milhÃµes de transaÃ§Ãµes
let currentPage = 1;
let itemsPerPage = 20;
let filteredTransactions = [];
let allLoadedTransactions = []; // Cache local limitado
let isLoadingMore = false;
let hasMoreTransactions = true;
let lastLoadedDoc = null; // Para cursor-based pagination
let maxCacheSize = 20; // Reduzido para apenas 20 transaÃ§Ãµes (uma pÃ¡gina)
let cacheCleanupTimer = null; // Timer para limpeza automÃ¡tica

// Estado de contas fixas
let filteredBills = [];
let currentBillForPayment = null;

// Listeners do Firestore
let accountsUnsubscribe = null;
let transactionsUnsubscribe = null;
let fixedBillsUnsubscribe = null;

// Elementos da UI
const loginScreen = document.getElementById('login-screen');
const appScreen = document.getElementById('app-screen');
const loginForm = document.getElementById('login-form');
const emailInput = document.getElementById('email');
const passwordInput = document.getElementById('password');
const loginBtn = document.getElementById('login-btn');
const signupBtn = document.getElementById('signup-btn');
const authError = document.getElementById('auth-error');
const logoutBtn = document.getElementById('logout-btn');
const chatInput = document.getElementById('chat-input');
const sendBtn = document.getElementById('send-btn');
const chatMessages = document.getElementById('chat-messages');

// Elementos do nome personalizado
const customNameInput = document.getElementById('custom-name-input');
const saveNameBtn = document.getElementById('save-name-btn');

// Elementos da sidebar
const totalBalance = document.getElementById('total-balance');
const monthlyIncome = document.getElementById('monthly-income');
const monthlyExpenses = document.getElementById('monthly-expenses');
const accountsList = document.getElementById('accounts-list');
const fixedBillsSection = document.getElementById('fixed-bills-section');
const recentTransactions = document.getElementById('recent-transactions');

// BotÃµes de gerenciamento
const manageAccountsBtn = document.getElementById('manage-accounts-btn');
const manageBillsBtn = document.getElementById('manage-bills-btn');
const addAccountBtn = document.getElementById('add-account-btn');
const addBillBtn = document.getElementById('add-bill-btn');
const viewAllBillsBtn = document.getElementById('view-all-bills-btn');
const viewAllTransactionsBtn = document.getElementById('view-all-transactions-btn');

// Modais
const accountsModal = document.getElementById('accounts-modal');
const billsModal = document.getElementById('bills-modal');
const billsViewModal = document.getElementById('bills-view-modal');
const partialPaymentModal = document.getElementById('partial-payment-modal');
const fullPaymentModal = document.getElementById('full-payment-modal');
const transactionsModal = document.getElementById('transactions-modal');
const confirmModal = document.getElementById('confirm-modal');

// Elementos dos modais
const closeAccountsModal = document.getElementById('close-accounts-modal');
const closeBillsModal = document.getElementById('close-bills-modal');
const closeBillsViewModal = document.getElementById('close-bills-view-modal');
const closePartialPaymentModal = document.getElementById('close-partial-payment-modal');
const closeFullPaymentModal = document.getElementById('close-full-payment-modal');
const closeTransactionsModal = document.getElementById('close-transactions-modal');
const confirmYesBtn = document.getElementById('confirm-yes-btn');
const confirmNoBtn = document.getElementById('confirm-no-btn');

// FormulÃ¡rios
const accountForm = document.getElementById('account-form');
const billForm = document.getElementById('bill-form');
const accountId = document.getElementById('account-id');
const accountName = document.getElementById('account-name');
const accountBalance = document.getElementById('account-balance');
const billId = document.getElementById('bill-id');
const billName = document.getElementById('bill-name');
const billAmount = document.getElementById('bill-amount');
const billDueDay = document.getElementById('bill-due-day');
const billCategory = document.getElementById('bill-category');

// Filtros de transaÃ§Ãµes
const transactionFilterType = document.getElementById('transaction-filter-type');
const transactionFilterAccount = document.getElementById('transaction-filter-account');
const transactionFilterDate = document.getElementById('transaction-filter-date');
const transactionsList = document.getElementById('transactions-list');
const prevPageBtn = document.getElementById('prev-page-btn');
const nextPageBtn = document.getElementById('next-page-btn');

// Filtros de contas fixas
const billStatusFilter = document.getElementById('bill-status-filter');
const billCategoryFilter = document.getElementById('bill-category-filter');
const billsViewList = document.getElementById('bills-view-list');

// Elementos de pagamento parcial
const partialPaymentAmount = document.getElementById('partial-payment-amount');
const partialPaymentAccount = document.getElementById('partial-payment-account');
const confirmPartialPaymentBtn = document.getElementById('confirm-partial-payment-btn');
const cancelPartialPaymentBtn = document.getElementById('cancel-partial-payment-btn');

// Elementos de pagamento completo
const fullPaymentAccount = document.getElementById('full-payment-account');
const confirmFullPaymentBtn = document.getElementById('confirm-full-payment-btn');
const cancelFullPaymentBtn = document.getElementById('cancel-full-payment-btn');

// InicializaÃ§Ã£o
document.addEventListener('DOMContentLoaded', () => {
    initializeAuth();
    setupEventListeners();
});

// FunÃ§Ã£o para salvar nome personalizado
async function saveCustomName() {
    const name = customNameInput.value.trim();
    
    if (!name) {
        alert('Por favor, digite um nome vÃ¡lido.');
        return;
    }
    
    try {
        await saveCustomUserName(name);
        customUserName = name;
        
        // Atualizar contexto do Gemini com o novo nome
        updateGeminiContext({
            userAccounts: accounts,
            fixedBills: fixedBills,
            recentTransactions: transactions.slice(0, 10),
            currentUser: currentUser,
            customUserName: customUserName
        });
        
        // Mostrar confirmaÃ§Ã£o
        addChatMessage('system', `Nome personalizado salvo: ${name}`);
        
        // Atualizar placeholder do input
        customNameInput.placeholder = name;
        customNameInput.value = '';
        
    } catch (error) {
        console.error('Erro ao salvar nome personalizado:', error);
        alert('Erro ao salvar nome. Tente novamente.');
    }
}

// FunÃ§Ã£o para carregar nome personalizado
async function loadCustomName() {
    try {
        const savedName = await loadCustomUserName();
        if (savedName) {
            customUserName = savedName;
            customNameInput.placeholder = savedName;
            
            // Atualizar contexto do Gemini
            updateGeminiContext({
                userAccounts: accounts,
                fixedBills: fixedBills,
                recentTransactions: transactions.slice(0, 10),
                currentUser: currentUser,
                customUserName: customUserName
            });
        }
    } catch (error) {
        console.error('Erro ao carregar nome personalizado:', error);
    }
}

// FunÃ§Ã£o para obter nome do usuÃ¡rio (personalizado ou padrÃ£o)
function getUserDisplayName() {
    return customUserName || 'usuÃ¡rio';
}

// Configurar listeners de autenticaÃ§Ã£o
function initializeAuth() {
    onAuthStateChangedListener(async (user) => {
        if (user) {
            currentUser = user;
            showAppScreen();
            setupFirestoreListeners();
            
            // Carregar nome personalizado
            await loadCustomName();
            
            const displayName = getUserDisplayName();
            addChatMessage('system', `Bem-vindo ao Dinah! Como posso ajudÃ¡-lo hoje?`);
        } else {
            currentUser = null;
            customUserName = null;
            showLoginScreen();
            cleanupFirestoreListeners();
        }
    });
}

// Configurar event listeners
function setupEventListeners() {
    // Login
    loginForm.addEventListener('submit', handleLogin);
    signupBtn.addEventListener('click', handleSignup);
    logoutBtn.addEventListener('click', handleLogout);
    
    // Chat
    sendBtn.addEventListener('click', handleSendMessage);
    chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleSendMessage();
        }
    });

    // Nome personalizado
    saveNameBtn.addEventListener('click', saveCustomName);
    customNameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            saveCustomName();
        }
    });

    // Gerenciamento de contas
    manageAccountsBtn.addEventListener('click', () => showModal(accountsModal));
    manageBillsBtn.addEventListener('click', () => showModal(billsModal));
    addAccountBtn.addEventListener('click', () => showModal(accountsModal));
    addBillBtn.addEventListener('click', () => showModal(billsModal));
    
    // Modal de ajuda
    const helpBtn = document.getElementById('help-btn');
    const helpModal = document.getElementById('help-modal');
    const closeHelpModal = document.getElementById('close-help-modal');
    
    if (helpBtn && helpModal && closeHelpModal) {
        helpBtn.addEventListener('click', () => {
            helpModal.classList.remove('hidden');
        });
        
        closeHelpModal.addEventListener('click', () => {
            helpModal.classList.add('hidden');
        });
        
        // Fechar ao clicar fora
        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) {
                helpModal.classList.add('hidden');
            }
        });
    }
    
    viewAllBillsBtn.addEventListener('click', async () => {
        showModal(billsViewModal);
        // Verificar e expandir perÃ­odos automaticamente
        await checkAndExpandAllBills();
        filterBills();
    });
    viewAllTransactionsBtn.addEventListener('click', async () => {
        showModal(transactionsModal);
        // Inicializar sistema otimizado de carregamento
        await initializeOptimizedTransactions();
    });

    // Fechar modais
    closeAccountsModal.addEventListener('click', () => hideModal(accountsModal));
    closeBillsModal.addEventListener('click', () => hideModal(billsModal));
    closeBillsViewModal.addEventListener('click', () => hideModal(billsViewModal));
    closePartialPaymentModal.addEventListener('click', () => hideModal(partialPaymentModal));
    closeFullPaymentModal.addEventListener('click', () => hideModal(fullPaymentModal));
    closeTransactionsModal.addEventListener('click', () => {
        hideModal(transactionsModal);
        // Limpar cache quando fechar modal de transaÃ§Ãµes
        clearTransactionCache();
    });
    confirmNoBtn.addEventListener('click', () => hideModal(confirmModal));
    
    // Event listeners para os novos modais
    const closeEditBillModal = document.getElementById('close-edit-bill-modal');
    const cancelEditBillBtn = document.getElementById('cancel-edit-bill-btn');
    const closePaymentHistoryModal = document.getElementById('close-payment-history-modal');
    
    if (closeEditBillModal) {
        closeEditBillModal.addEventListener('click', () => {
            document.getElementById('edit-bill-modal').classList.add('hidden');
        });
    }
    
    if (cancelEditBillBtn) {
        cancelEditBillBtn.addEventListener('click', () => {
            document.getElementById('edit-bill-modal').classList.add('hidden');
        });
    }
    
    if (closePaymentHistoryModal) {
        closePaymentHistoryModal.addEventListener('click', () => {
            document.getElementById('payment-history-modal').classList.add('hidden');
        });
    }
    
    // Fechar modais ao clicar fora
    const editBillModal = document.getElementById('edit-bill-modal');
    const paymentHistoryModal = document.getElementById('payment-history-modal');
    
    if (editBillModal) {
        editBillModal.addEventListener('click', (e) => {
            if (e.target === editBillModal) {
                editBillModal.classList.add('hidden');
            }
        });
    }
    
    if (paymentHistoryModal) {
        paymentHistoryModal.addEventListener('click', (e) => {
            if (e.target === paymentHistoryModal) {
                paymentHistoryModal.classList.add('hidden');
            }
        });
    }

    // FormulÃ¡rios
    accountForm.addEventListener('submit', handleAccountSubmit);
    billForm.addEventListener('submit', handleBillSubmit);

    // BotÃµes de cancelar
    document.getElementById('cancel-account-btn').addEventListener('click', () => {
        resetAccountForm();
        hideModal(accountsModal);
    });
    document.getElementById('cancel-bill-btn').addEventListener('click', () => {
        resetBillForm();
        hideModal(billsModal);
    });

    // Filtros de transaÃ§Ãµes
    transactionFilterType.addEventListener('change', filterTransactions);
    transactionFilterAccount.addEventListener('change', filterTransactions);
    transactionFilterDate.addEventListener('change', filterTransactions);

    // Filtros de contas fixas
    billStatusFilter.addEventListener('change', filterBills);
    billCategoryFilter.addEventListener('change', filterBills);

    // PaginaÃ§Ã£o
    prevPageBtn.addEventListener('click', () => changePage(-1));
    nextPageBtn.addEventListener('click', () => changePage(1));

    // ConfirmaÃ§Ã£o
    confirmYesBtn.addEventListener('click', handleConfirmDelete);

    // Pagamento parcial
    confirmPartialPaymentBtn.addEventListener('click', handlePartialPayment);
    cancelPartialPaymentBtn.addEventListener('click', () => hideModal(partialPaymentModal));

    // Pagamento completo
    confirmFullPaymentBtn.addEventListener('click', handleFullPayment);
    cancelFullPaymentBtn.addEventListener('click', () => hideModal(fullPaymentModal));

    // BotÃ£o para deletar todas as transaÃ§Ãµes
    document.getElementById('delete-all-transactions-btn').addEventListener('click', () => {
        showConfirmModal(
            'Deletar Todas as TransaÃ§Ãµes', 
            'âš ï¸ ATENÃ‡ÃƒO: Esta aÃ§Ã£o irÃ¡ deletar TODAS as suas transaÃ§Ãµes e resetar os saldos das contas para zero. Esta aÃ§Ã£o nÃ£o pode ser desfeita e afetarÃ¡ apenas os seus dados (nÃ£o da sua esposa).\n\nTem certeza que deseja continuar?', 
            () => deleteAllTransactions()
        );
    });
}

// Handlers de autenticaÃ§Ã£o
async function handleLogin(e) {
    e.preventDefault();
    
    const email = emailInput.value;
    const password = passwordInput.value;
    
    if (!email || !password) {
        showAuthError('Por favor, preencha todos os campos.');
        return;
    }
    
    loginBtn.disabled = true;
    loginBtn.textContent = 'Entrando...';
    
    try {
        const result = await signInUser(email, password);
        if (result.success) {
            hideAuthError();
        } else {
            showAuthError(result.error);
        }
    } catch (error) {
        showAuthError('Erro ao fazer login. Tente novamente.');
    } finally {
        loginBtn.disabled = false;
        loginBtn.textContent = 'Entrar';
    }
}

async function handleSignup() {
    const email = emailInput.value;
    const password = passwordInput.value;
    
    if (!email || !password) {
        showAuthError('Por favor, preencha todos os campos.');
        return;
    }
    
    signupBtn.disabled = true;
    signupBtn.textContent = 'Cadastrando...';
    
    try {
        const result = await signUpUser(email, password);
        if (result.success) {
            hideAuthError();
        } else {
            showAuthError(result.error);
        }
    } catch (error) {
        showAuthError('Erro ao cadastrar. Tente novamente.');
    } finally {
        signupBtn.disabled = false;
        signupBtn.textContent = 'Cadastrar';
    }
}

async function handleLogout() {
    try {
        await signOutUser();
        contextManager.clear();
    } catch (error) {
        console.error('Erro ao fazer logout:', error);
    }
}

// Configurar listeners do Firestore com otimizaÃ§Ã£o para milhÃµes de transaÃ§Ãµes
function setupFirestoreListeners() {
    accountsUnsubscribe = onAccountsUpdate((accountsData) => {
        accounts = accountsData;
        renderAccounts();
        renderAccountsManagement();
        updateFinancialSummary();
        updateTransactionFilters();
    });
    
    transactionsUnsubscribe = onTransactionsUpdate((transactionsData) => {
        // OtimizaÃ§Ã£o: Manter apenas as Ãºltimas 50 transaÃ§Ãµes em memÃ³ria para o listener
        // O sistema de paginaÃ§Ã£o carregarÃ¡ mais conforme necessÃ¡rio
        transactions = transactionsData.slice(0, 50);
        
        console.log('ðŸ’¾ TransaÃ§Ãµes recentes carregadas:', transactions.length);
        
        updateFinancialSummary();
        renderRecentTransactions();
        
        // Atualizar status das contas fixas quando transaÃ§Ãµes mudam
        if (fixedBills && fixedBills.length > 0) {
            updateFixedBillsStatus();
        }
    });
    
    fixedBillsUnsubscribe = onFixedBillsUpdate((fixedBillsData) => {
        fixedBills = fixedBillsData;
        updateFixedBillsStatus();
        renderFixedBills();
        renderBillsManagement();
        // Inicializar filtros de contas fixas
        filteredBills = [...fixedBills];
        renderBillsView();
    });
}

// FunÃ§Ã£o para atualizar status das contas fixas
async function updateFixedBillsStatus() {
    try {
        // Buscar status atualizado de todas as contas fixas
        const billsWithStatus = await getFixedBillsWithStatus();
        
        // Atualizar o array de contas fixas com os status calculados
        fixedBills = billsWithStatus;
        
        // Verificar se alguma conta precisa de expansÃ£o automÃ¡tica (processamento no servidor)
        let needsExpansion = false;
        
        for (const bill of fixedBills) {
            // Verificar se a auto-expansÃ£o estÃ¡ habilitada
            if (!bill.autoExpansionEnabled) continue;
            
            // Usar o lastPaidPeriod jÃ¡ calculado pela funÃ§Ã£o getFixedBillStatus (processamento no servidor)
            if (bill.lastPaidPeriod) {
                const initialDate = bill.initialDate?.toDate ? bill.initialDate.toDate() : new Date(bill.initialDate);
                const totalPeriods = bill.totalPeriodsGenerated || 12;
                const periods = calculateAllPeriodsFromInitial(initialDate, bill.dueDay, totalPeriods, false);
                
                // Encontrar Ã­ndice do Ãºltimo perÃ­odo pago
                const lastPaidIndex = periods.findIndex(p => p.period === bill.lastPaidPeriod.period);
                
                // Calcular perÃ­odos restantes
                const periodsRemaining = periods.length - (lastPaidIndex + 1);
                
                // CORREÃ‡ÃƒO: ExpansÃ£o acontece quando restam 5 ou menos perÃ­odos
                if (periodsRemaining <= 5) {
                    needsExpansion = true;
                    break; // Sair do loop se encontrou uma conta que precisa expandir
                }
            } else {
                // Se nÃ£o tem pagamento ainda, verificar se precisa expandir
                const initialDate = bill.initialDate?.toDate ? bill.initialDate.toDate() : new Date(bill.initialDate);
                const totalPeriods = bill.totalPeriodsGenerated || 12;
                const periods = calculateAllPeriodsFromInitial(initialDate, bill.dueDay, totalPeriods, false);
                
                // Se tem poucos perÃ­odos restantes, precisa expandir
                if (periods.length <= 5) {
                    needsExpansion = true;
                    break;
                }
            }
        }
        
        if (needsExpansion) {
            await checkAndExpandAllBills();
        }
        
        // Atualizar filtros
        filteredBills = [...fixedBills];
        
        // Re-renderizar componentes
        renderFixedBills();
        renderBillsView();
        
    } catch (error) {
        console.error('Erro ao atualizar status das contas fixas:', error);
        // Em caso de erro, usar cÃ¡lculo local como fallback
        renderFixedBills();
        renderBillsView();
    }
}

// Limpar listeners do Firestore
function cleanupFirestoreListeners() {
    if (accountsUnsubscribe) {
        accountsUnsubscribe();
        accountsUnsubscribe = null;
    }
    if (transactionsUnsubscribe) {
        transactionsUnsubscribe();
        transactionsUnsubscribe = null;
    }
    if (fixedBillsUnsubscribe) {
        fixedBillsUnsubscribe();
        fixedBillsUnsubscribe = null;
    }
}

// Processar resultado do Gemini e executar aÃ§Ãµes apropriadas
async function processGeminiResult(result, originalMessage) {
    try {
        // Mostrar resposta do Gemini APENAS se nÃ£o for uma aÃ§Ã£o que precisa de confirmaÃ§Ã£o
        if (result.response && !result.needsDatabaseQuery && result.intent !== 'ADD_EXPENSE' && result.intent !== 'ADD_INCOME' && result.intent !== 'PERFORM_TRANSFER' && result.intent !== 'PAY_FIXED_BILL') {
            addChatMessage('assistant', result.response);
        }
        
        // Se precisa consultar banco de dados, fazer a consulta
        if (result.needsDatabaseQuery) {
            await handleDatabaseQuery(result.queryType, originalMessage);
            return;
        }
        
        // Executar aÃ§Ã£o baseada na intenÃ§Ã£o
        switch (result.intent) {
            case 'ADD_EXPENSE':
                await handleAddExpense(result.entities, originalMessage);
                break;
            case 'ADD_INCOME':
                await handleAddIncome(result.entities, originalMessage);
                break;
            case 'PERFORM_TRANSFER':
                await handleTransfer(result.entities, originalMessage);
                break;
            case 'PAY_FIXED_BILL':
                await handlePayFixedBill(result.entities, originalMessage);
                break;
            case 'QUERY_BALANCE':
                await handleQueryBalance(result.entities, originalMessage);
                break;
            case 'QUERY_TRANSACTIONS':
                await handleQueryTransactions(result.entities, originalMessage);
                break;
            case 'QUERY_FIXED_BILLS':
                await handleUnpaidBills(originalMessage);
                break;
            case 'QUERY_FINANCIAL_SUMMARY':
                await handleFinancialSummary(originalMessage);
                break;
            case 'ADD_DEBT':
                await handleAddDebt(result.entities, originalMessage);
                break;
            case 'GREETING':
            case 'HELP':
                // Para saudaÃ§Ãµes, mostrar apenas a resposta do Gemini
                if (result.response) {
                    addChatMessage('assistant', result.response);
                }
                break;
            default:
                console.warn('IntenÃ§Ã£o nÃ£o reconhecida:', result.intent);
                // SÃ³ mostrar mensagem de erro se nÃ£o tiver resposta do Gemini
                if (!result.response) {
                    addChatMessage('assistant', 'Desculpe, nÃ£o entendi sua solicitaÃ§Ã£o. Pode reformular?');
                }
        }
    } catch (error) {
        console.error('Erro ao processar resultado do Gemini:', error);
        addChatMessage('assistant', 'âŒ Ocorreu um erro ao processar sua solicitaÃ§Ã£o. Tente novamente.');
    }
}

// Handler para consultas ao banco de dados
async function handleDatabaseQuery(queryType, originalMessage) {
    try {
        switch (queryType) {
            case 'expenses_by_date':
                await handleExpensesByDate(originalMessage);
                break;
            case 'income_by_date':
                await handleIncomeByDate(originalMessage);
                break;
            case 'transactions_by_period':
                await handleTransactionsByPeriod(originalMessage);
                break;
            case 'monthly_summary':
                await handleMonthlySummary(originalMessage);
                break;
            case 'unpaid_bills':
                await handleUnpaidBills(originalMessage);
                break;
            case 'financial_summary':
                await handleFinancialSummary(originalMessage);
                break;
            default:
                addChatMessage('assistant', 'ðŸ“Š Consultando dados no banco...');
                await handleQueryTransactions({}, originalMessage);
        }
    } catch (error) {
        console.error('Erro ao consultar banco de dados:', error);
        addChatMessage('assistant', 'âŒ Erro ao consultar dados. Tente novamente.');
    }
}

// Handler para gastos por data
async function handleExpensesByDate(originalMessage) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const endOfToday = new Date();
    endOfToday.setHours(23, 59, 59, 999);
    
    console.log('ðŸ” Buscando gastos de hoje:', today.toLocaleDateString('pt-BR'));
    console.log('ðŸ” Total de transaÃ§Ãµes:', transactions.length);
    
    const todayExpenses = transactions.filter(t => {
        if (t.type !== 'expense') return false;
        
        let transactionDate;
        try {
            // Tratamento robusto de diferentes tipos de data
            if (t.date && typeof t.date.toDate === 'function') {
                transactionDate = t.date.toDate();
            } else if (t.date && typeof t.date.seconds === 'number') {
                transactionDate = new Date(t.date.seconds * 1000);
            } else if (t.date instanceof Date) {
                transactionDate = t.date;
            } else if (typeof t.date === 'string' || typeof t.date === 'number') {
                transactionDate = new Date(t.date);
            } else {
                console.warn('Data invÃ¡lida encontrada:', t.date);
                return false;
            }
            
            // Verificar se a data Ã© vÃ¡lida
            if (isNaN(transactionDate.getTime())) {
                console.warn('Data invÃ¡lida apÃ³s conversÃ£o:', t.date);
                return false;
            }
            
            const isToday = transactionDate >= today && transactionDate <= endOfToday;
            
            if (isToday) {
                console.log('âœ… Gasto de hoje encontrado:', t.description, t.amount, transactionDate.toLocaleDateString('pt-BR'));
            }
            
            return isToday;
        } catch (error) {
            console.error('Erro ao processar data da transaÃ§Ã£o:', error, t.date);
            return false;
        }
    });
    
    console.log('ðŸ” Gastos de hoje encontrados:', todayExpenses.length);
    
    if (todayExpenses.length === 0) {
        addChatMessage('assistant', `${getUserDisplayName()}, vocÃª nÃ£o teve gastos hoje.`);
        return;
    }
    
    const totalExpenses = todayExpenses.reduce((sum, t) => sum + t.amount, 0);
    
    let response = `${getUserDisplayName()}, aqui estÃ£o seus gastos de hoje (${today.toLocaleDateString('pt-BR')}):\n\n`;
    response += `ðŸ’° **Total:** R$ ${totalExpenses.toFixed(2)}\n\n`;
    
    todayExpenses.forEach(t => {
        const time = t.date && typeof t.date.toDate === 'function' 
            ? t.date.toDate().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })
            : 'N/A';
        response += `ðŸ’¸ **${t.description}** - R$ ${t.amount.toFixed(2)} (${time})\n`;
    });
    
    addChatMessage('assistant', response);
}

// Handler para resumo financeiro completo
async function handleFinancialSummary(originalMessage) {
    try {
        const today = new Date();
        const currentMonth = today.getMonth();
        const currentYear = today.getFullYear();
        
        // Calcular totais gerais
        const totalBalance = accounts.reduce((sum, acc) => sum + acc.balance, 0);
        
        // Filtrar transaÃ§Ãµes do mÃªs atual
        const monthlyTransactions = transactions.filter(t => {
            if (!t.date) return false;
            
            let transactionDate;
            try {
                if (t.date && typeof t.date.toDate === 'function') {
                    transactionDate = t.date.toDate();
                } else if (t.date && typeof t.date.seconds === 'number') {
                    transactionDate = new Date(t.date.seconds * 1000);
                } else if (t.date instanceof Date) {
                    transactionDate = t.date;
                } else {
                    transactionDate = new Date(t.date);
                }
                
                return transactionDate.getMonth() === currentMonth && 
                       transactionDate.getFullYear() === currentYear;
            } catch (error) {
                return false;
            }
        });
        
        // Calcular gastos e receitas do mÃªs
        const monthlyExpenses = monthlyTransactions
            .filter(t => t.type === 'expense')
            .reduce((sum, t) => sum + t.amount, 0);
            
        const monthlyIncome = monthlyTransactions
            .filter(t => t.type === 'income')
            .reduce((sum, t) => sum + t.amount, 0);
        
        // Calcular gastos de hoje
        const todayExpenses = transactions.filter(t => {
            if (t.type !== 'expense') return false;
            
            let transactionDate;
            try {
                if (t.date && typeof t.date.toDate === 'function') {
                    transactionDate = t.date.toDate();
                } else if (t.date && typeof t.date.seconds === 'number') {
                    transactionDate = new Date(t.date.seconds * 1000);
                } else if (t.date instanceof Date) {
                    transactionDate = t.date;
                } else {
                    transactionDate = new Date(t.date);
                }
                
                const today = new Date();
                return transactionDate.toDateString() === today.toDateString();
            } catch (error) {
                return false;
            }
        }).reduce((sum, t) => sum + t.amount, 0);
        
        // Contas fixas nÃ£o pagas
        const unpaidBills = fixedBills.filter(bill => {
            const billPayments = transactions.filter(t => 
                t.billId === bill.id && 
                t.isBillPayment === true &&
                new Date(t.date).getMonth() === currentMonth &&
                new Date(t.date).getFullYear() === currentYear
            );
            return billPayments.length === 0;
        });
        
        const totalUnpaidBills = unpaidBills.reduce((sum, bill) => sum + bill.amount, 0);
        
        // AnÃ¡lise por categoria
        const categoryAnalysis = {};
        monthlyTransactions.filter(t => t.type === 'expense').forEach(t => {
            const category = t.category || 'outros';
            if (!categoryAnalysis[category]) {
                categoryAnalysis[category] = 0;
            }
            categoryAnalysis[category] += t.amount;
        });
        
        // Top 3 categorias de gasto
        const topCategories = Object.entries(categoryAnalysis)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 3);
        
        // Construir resposta
        let response = `${getUserDisplayName()}, aqui estÃ¡ seu resumo financeiro completo:\n\n`;
        
        // Saldo total
        response += `ðŸ’° **SALDO TOTAL:** R$ ${totalBalance.toFixed(2)}\n\n`;
        
        // Resumo do mÃªs
        response += `ðŸ“Š **RESUMO DO MÃŠS (${today.toLocaleDateString('pt-BR', { month: 'long', year: 'numeric' })})**\n`;
        response += `ðŸ“ˆ **Receitas:** R$ ${monthlyIncome.toFixed(2)}\n`;
        response += `ðŸ“‰ **Gastos:** R$ ${monthlyExpenses.toFixed(2)}\n`;
        response += `ðŸ’µ **Saldo do mÃªs:** R$ ${(monthlyIncome - monthlyExpenses).toFixed(2)}\n\n`;
        
        // Gastos de hoje
        response += `ðŸ“… **GASTOS DE HOJE:** R$ ${todayExpenses.toFixed(2)}\n\n`;
        
        // Contas fixas
        if (unpaidBills.length > 0) {
            response += `âš ï¸ **CONTAS FIXAS NÃƒO PAGAS:**\n`;
            unpaidBills.forEach(bill => {
                const dueDate = new Date(currentYear, currentMonth, bill.dueDay);
                const isOverdue = today > dueDate;
                const status = isOverdue ? 'ðŸ”´ VENCIDA' : 'ðŸŸ¡ Pendente';
                response += `${status} **${bill.name}** - R$ ${bill.amount.toFixed(2)} (vence dia ${bill.dueDay})\n`;
            });
            response += `\nðŸ’° **Total em aberto:** R$ ${totalUnpaidBills.toFixed(2)}\n\n`;
        } else {
            response += `âœ… **Todas as contas fixas estÃ£o em dia!**\n\n`;
        }
        
        // Top categorias
        if (topCategories.length > 0) {
            response += `ðŸ† **TOP CATEGORIAS DE GASTO:**\n`;
            topCategories.forEach(([category, amount], index) => {
                const percentage = monthlyExpenses > 0 ? ((amount / monthlyExpenses) * 100).toFixed(1) : 0;
                response += `${index + 1}. **${category}** - R$ ${amount.toFixed(2)} (${percentage}%)\n`;
            });
            response += `\n`;
        }
        
        // Saldo por conta
        response += `ðŸ¦ **SALDO POR CONTA:**\n`;
        accounts.forEach(account => {
            const percentage = totalBalance > 0 ? ((account.balance / totalBalance) * 100).toFixed(1) : 0;
            response += `â€¢ **${account.name}:** R$ ${account.balance.toFixed(2)} (${percentage}%)\n`;
        });
        
        addChatMessage('assistant', response);
        
    } catch (error) {
        console.error('Erro ao gerar resumo financeiro:', error);
        addChatMessage('assistant', `${getUserDisplayName()}, ocorreu um erro ao gerar o resumo financeiro. Tente novamente.`);
    }
}

// Handler para receitas por data
async function handleIncomeByDate(originalMessage) {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday.setHours(0, 0, 0, 0);
    
    const today = new Date();
    today.setHours(23, 59, 59, 999);
    
    const yesterdayIncome = transactions.filter(t => {
        const transactionDate = new Date(t.date);
        return t.type === 'income' && 
               transactionDate >= yesterday && 
               transactionDate <= today;
    });
    
    if (yesterdayIncome.length === 0) {
        addChatMessage('assistant', 'ðŸ“Š VocÃª nÃ£o teve receitas ontem.');
        return;
    }
    
    const totalIncome = yesterdayIncome.reduce((sum, t) => sum + t.amount, 0);
    
    let response = `ðŸ“Š **Receitas de ontem (${yesterday.toLocaleDateString('pt-BR')}):**\n\n`;
    response += `ðŸ’° **Total:** R$ ${totalIncome.toFixed(2)}\n\n`;
    
    yesterdayIncome.forEach(t => {
        response += `ðŸ’° **${t.description}** - R$ ${t.amount.toFixed(2)}\n`;
    });
    
    addChatMessage('assistant', response);
}

// Handler para transaÃ§Ãµes por perÃ­odo
async function handleTransactionsByPeriod(originalMessage) {
    const today = new Date();
    const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    
    const monthlyTransactions = transactions.filter(t => {
        const transactionDate = new Date(t.date);
        return transactionDate >= startOfMonth;
    });
    
    if (monthlyTransactions.length === 0) {
        addChatMessage('assistant', 'ðŸ“Š VocÃª nÃ£o tem transaÃ§Ãµes este mÃªs.');
        return;
    }
    
    const expenses = monthlyTransactions.filter(t => t.type === 'expense');
    const income = monthlyTransactions.filter(t => t.type === 'income');
    
    const totalExpenses = expenses.reduce((sum, t) => sum + t.amount, 0);
    const totalIncome = income.reduce((sum, t) => sum + t.amount, 0);
    const balance = totalIncome - totalExpenses;
    
    let response = `ðŸ“Š **Resumo do mÃªs (${today.toLocaleDateString('pt-BR', { month: 'long', year: 'numeric' })}):**\n\n`;
    response += `ðŸ’° **Receitas:** R$ ${totalIncome.toFixed(2)}\n`;
    response += `ðŸ’¸ **Despesas:** R$ ${totalExpenses.toFixed(2)}\n`;
    response += `ðŸ“ˆ **Saldo:** R$ ${balance.toFixed(2)}\n\n`;
    response += `ðŸ“‹ **Total de transaÃ§Ãµes:** ${monthlyTransactions.length}`;
    
    addChatMessage('assistant', response);
}

// Handler para resumo mensal
async function handleMonthlySummary(originalMessage) {
    await handleTransactionsByPeriod(originalMessage);
}

// Handler para contas fixas nÃ£o pagas
async function handleUnpaidBills(originalMessage) {
    if (fixedBills.length === 0) {
        addChatMessage('assistant', 'ðŸ“‹ VocÃª nÃ£o tem contas fixas cadastradas.');
        return;
    }
    
    const today = new Date();
    const currentMonth = today.getMonth() + 1;
    const currentYear = today.getFullYear();
    
    let unpaidBills = [];
    
    for (const bill of fixedBills) {
        // Verificar se a conta fixa jÃ¡ foi paga este mÃªs
        const billPayments = transactions.filter(t => 
            t.billId === bill.id && 
            t.isBillPayment === true &&
            new Date(t.date).getMonth() + 1 === currentMonth &&
            new Date(t.date).getFullYear() === currentYear
        );
        
        if (billPayments.length === 0) {
            unpaidBills.push(bill);
        }
    }
    
    if (unpaidBills.length === 0) {
        addChatMessage('assistant', 'âœ… Todas as suas contas fixas estÃ£o em dia!');
        return;
    }
    
    let response = `ðŸ“‹ **Contas fixas nÃ£o pagas este mÃªs:**\n\n`;
    
    unpaidBills.forEach(bill => {
        const dueDate = new Date(currentYear, currentMonth - 1, bill.dueDay);
        const isOverdue = today > dueDate;
        const status = isOverdue ? 'ðŸ”´ VENCIDA' : 'ðŸŸ¡ Pendente';
        
        response += `${status} **${bill.name}**\n`;
        response += `   ðŸ’° R$ ${bill.amount.toFixed(2)} - Vence dia ${bill.dueDay}\n\n`;
    });
    
    addChatMessage('assistant', response);
}

// Handler para adicionar despesa
async function handleAddExpense(entities, originalMessage) {
    if (!entities.amount || entities.amount <= 0) {
        addChatMessage('assistant', 'Por favor, informe um valor vÃ¡lido para a despesa.');
        return;
    }
    
    const description = entities.description || 'Despesa';
    const category = entities.category || 'outros';
    
    // Se nÃ£o especificou conta, perguntar
    if (!entities.fromAccount) {
        addChatMessage('assistant', `Registrei sua despesa de R$ ${entities.amount.toFixed(2)} - ${description}. De qual conta vocÃª quer debitar?`, [
            ...accounts.map(acc => ({ text: acc.name, action: `debitar_${acc.name}` }))
        ]);
        return;
    }
    
    // Encontrar conta
    const account = accounts.find(acc => 
        acc.name.toLowerCase().includes(entities.fromAccount.toLowerCase()) ||
        entities.fromAccount.toLowerCase().includes(acc.name.toLowerCase())
    );
    
    if (!account) {
        addChatMessage('assistant', `âŒ Conta "${entities.fromAccount}" nÃ£o encontrada. Contas disponÃ­veis: ${accounts.map(a => a.name).join(', ')}`);
        return;
    }
    
    // Verificar saldo suficiente
    if (account.balance < entities.amount) {
        addChatMessage('assistant', `âŒ Saldo insuficiente na conta ${account.name}. Saldo atual: R$ ${account.balance.toFixed(2)}`);
        return;
    }
    
    // Calcular data baseada na referÃªncia (hoje, ontem, anteontem)
    const transactionDate = calculateDateFromReference(entities.dateReference);
    
    // Adicionar transaÃ§Ã£o
    await addTransaction({
        type: 'expense',
        amount: entities.amount,
        description: description,
        accountId: account.id,
        category: category,
        date: transactionDate
    });
    
    const dateText = entities.dateReference === 'ontem' ? 'de ontem' : 
                     entities.dateReference === 'anteontem' ? 'de anteontem' : '';
    
    addChatMessage('assistant', `${getUserDisplayName()}, despesa de R$ ${entities.amount.toFixed(2)} ${dateText} registrada na conta ${account.name} - ${description}`);
}

// Handler para adicionar receita
async function handleAddIncome(entities, originalMessage) {
    if (!entities.amount || entities.amount <= 0) {
        addChatMessage('assistant', 'Por favor, informe um valor vÃ¡lido para a receita.');
        return;
    }
    
    const description = entities.description || 'Receita';
    const category = entities.category || 'outros';
    
    // Se nÃ£o especificou conta, perguntar
    if (!entities.toAccount) {
        addChatMessage('assistant', `Registrei sua receita de R$ ${entities.amount.toFixed(2)} - ${description}. Em qual conta vocÃª quer creditar?`, [
            ...accounts.map(acc => ({ text: acc.name, action: `creditar_${acc.name}` }))
        ]);
        return;
    }
    
    // Encontrar conta
    const account = accounts.find(acc => 
        acc.name.toLowerCase().includes(entities.toAccount.toLowerCase()) ||
        entities.toAccount.toLowerCase().includes(acc.name.toLowerCase())
    );
    
    if (!account) {
        addChatMessage('assistant', `âŒ Conta "${entities.toAccount}" nÃ£o encontrada. Contas disponÃ­veis: ${accounts.map(a => a.name).join(', ')}`);
        return;
    }
    
    // Calcular data baseada na referÃªncia (hoje, ontem, anteontem)
    const transactionDate = calculateDateFromReference(entities.dateReference);
    
    // Adicionar transaÃ§Ã£o
    await addTransaction({
        type: 'income',
        amount: entities.amount,
        description: description,
        accountId: account.id,
        category: category,
        date: transactionDate
    });
    
    const dateText = entities.dateReference === 'ontem' ? 'de ontem' : 
                     entities.dateReference === 'anteontem' ? 'de anteontem' : '';
    
    addChatMessage('assistant', `${getUserDisplayName()}, receita de R$ ${entities.amount.toFixed(2)} ${dateText} registrada na conta ${account.name} - ${description}`);
}

// Handler para transferÃªncia
async function handleTransfer(entities, originalMessage) {
    if (!entities.amount || entities.amount <= 0) {
        addChatMessage('assistant', 'Por favor, informe um valor vÃ¡lido para a transferÃªncia.');
        return;
    }
    
    if (!entities.fromAccount || !entities.toAccount) {
        addChatMessage('assistant', 'Por favor, especifique as contas de origem e destino para a transferÃªncia.');
        return;
    }
    
    // Encontrar contas
    const fromAccount = accounts.find(acc => 
        acc.name.toLowerCase().includes(entities.fromAccount.toLowerCase()) ||
        entities.fromAccount.toLowerCase().includes(acc.name.toLowerCase())
    );
    
    const toAccount = accounts.find(acc => 
        acc.name.toLowerCase().includes(entities.toAccount.toLowerCase()) ||
        entities.toAccount.toLowerCase().includes(acc.name.toLowerCase())
    );
    
    if (!fromAccount) {
        addChatMessage('assistant', `âŒ Conta de origem "${entities.fromAccount}" nÃ£o encontrada. Contas disponÃ­veis: ${accounts.map(a => a.name).join(', ')}`);
        return;
    }
    
    if (!toAccount) {
        addChatMessage('assistant', `âŒ Conta de destino "${entities.toAccount}" nÃ£o encontrada. Contas disponÃ­veis: ${accounts.map(a => a.name).join(', ')}`);
        return;
    }
    
    if (fromAccount.id === toAccount.id) {
        addChatMessage('assistant', 'âŒ NÃ£o Ã© possÃ­vel transferir para a mesma conta.');
        return;
    }
    
    // Verificar saldo suficiente na conta de origem
    if (fromAccount.balance < entities.amount) {
        addChatMessage('assistant', `âŒ Saldo insuficiente na conta ${fromAccount.name}. Saldo atual: R$ ${fromAccount.balance.toFixed(2)}`);
        return;
    }
    
    // Executar transferÃªncia
    await performTransfer(fromAccount.id, toAccount.id, entities.amount, 'TransferÃªncia entre contas');
    
    addChatMessage('assistant', `âœ… TransferÃªncia de R$ ${entities.amount.toFixed(2)} realizada de ${fromAccount.name} para ${toAccount.name}`);
}

// Handler para pagamento de conta fixa
async function handlePayFixedBill(entities, originalMessage) {
    if (!entities.fixedBillName) {
        addChatMessage('assistant', 'Por favor, especifique qual conta fixa vocÃª pagou.');
        return;
    }
    
    // Encontrar conta fixa
    const fixedBill = fixedBills.find(bill => 
        bill.name.toLowerCase().includes(entities.fixedBillName.toLowerCase()) ||
        entities.fixedBillName.toLowerCase().includes(bill.name.toLowerCase())
    );
    
    if (!fixedBill) {
        addChatMessage('assistant', `âŒ Conta fixa "${entities.fixedBillName}" nÃ£o encontrada. Contas fixas disponÃ­veis: ${fixedBills.map(b => b.name).join(', ')}`);
        return;
    }
    
    // Perguntar de qual conta pagou
    addChatMessage('assistant', `Ã“timo! Registrei o pagamento da conta fixa "${fixedBill.name}". De qual conta vocÃª pagou?`, [
        ...accounts.map(acc => ({ text: acc.name, action: `pagar_conta_fixa_${fixedBill.id}_${acc.id}` }))
    ]);
}

// Handler para consulta de saldo
async function handleQueryBalance(entities, originalMessage) {
    if (entities.fromAccount) {
        // Saldo de conta especÃ­fica
        const account = accounts.find(acc => 
            acc.name.toLowerCase().includes(entities.fromAccount.toLowerCase()) ||
            entities.fromAccount.toLowerCase().includes(acc.name.toLowerCase())
        );
        
        if (account) {
            addChatMessage('assistant', `ðŸ’° **Saldo da conta ${account.name}:** R$ ${account.balance.toFixed(2)}`);
        } else {
            addChatMessage('assistant', `âŒ Conta "${entities.fromAccount}" nÃ£o encontrada. Contas disponÃ­veis: ${accounts.map(a => a.name).join(', ')}`);
        }
    } else {
        // Saldo total
        const totalBalance = accounts.reduce((sum, acc) => sum + acc.balance, 0);
        addChatMessage('assistant', `ðŸ’° **Seu saldo total:** R$ ${totalBalance.toFixed(2)}`);
        
        // Mostrar saldo por conta
        if (accounts.length > 1) {
            const accountsInfo = accounts.map(acc => 
                `â€¢ **${acc.name}:** R$ ${acc.balance.toFixed(2)}`
            ).join('\n');
            addChatMessage('assistant', `\nðŸ“Š **Saldo por conta:**\n${accountsInfo}`);
        }
    }
}

// Handler para consulta de transaÃ§Ãµes
async function handleQueryTransactions(entities, originalMessage) {
    // Se nÃ£o especificou tipo de consulta, mostrar transaÃ§Ãµes recentes
    const recentTransactions = transactions.slice(0, 10);
    
    if (recentTransactions.length === 0) {
        addChatMessage('assistant', 'ðŸ“‹ VocÃª ainda nÃ£o tem transaÃ§Ãµes registradas.');
        return;
    }
    
    let response = `ðŸ“‹ **Suas Ãºltimas ${recentTransactions.length} transaÃ§Ãµes:**\n\n`;
    
    recentTransactions.forEach(t => {
        const icon = t.type === 'expense' ? 'ðŸ’¸' : t.type === 'income' ? 'ðŸ’°' : 'ðŸ”„';
        const date = new Date(t.date).toLocaleDateString('pt-BR');
        response += `${icon} **${t.description}**\n`;
        response += `   ðŸ’° R$ ${t.amount.toFixed(2)} - ${date}\n\n`;
    });
    
    addChatMessage('assistant', response);
}

// Handler para adicionar dÃ­vida
async function handleAddDebt(entities, originalMessage) {
    if (!entities.amount || entities.amount <= 0) {
        addChatMessage('assistant', 'Por favor, informe um valor vÃ¡lido para a dÃ­vida.');
        return;
    }
    
    const description = entities.description || 'DÃ­vida';
    
    await addDebt({
        amount: entities.amount,
        description: description,
        creditor: entities.toAccount || 'NÃ£o especificado',
        date: new Date()
    });
    
    addChatMessage('assistant', `ðŸ“ DÃ­vida de R$ ${entities.amount.toFixed(2)} registrada - ${description}`);
}

// Handler principal de mensagens
async function handleSendMessage() {
    const message = chatInput.value.trim();
    if (!message) return;
    
    // Adicionar mensagem do usuÃ¡rio
    addChatMessage('user', message);
    chatInput.value = '';
    
    try {
        // ValidaÃ§Ã£o robusta dos dados antes do processamento
        if (!currentUser) {
            throw new Error('UsuÃ¡rio nÃ£o autenticado');
        }
        
        if (!accounts || !Array.isArray(accounts)) {
            console.warn('accounts invÃ¡lido:', accounts);
            accounts = [];
        }
        
        if (!fixedBills || !Array.isArray(fixedBills)) {
            console.warn('fixedBills invÃ¡lido:', fixedBills);
            fixedBills = [];
        }
        
        // Atualizar contexto do Gemini com dados atuais
        updateGeminiContext({
            userAccounts: accounts,
            fixedBills: fixedBills,
            recentTransactions: transactions.slice(0, 10), // Ãšltimas 10 transaÃ§Ãµes
            currentUser: currentUser,
            customUserName: customUserName
        });
        
        // Processar mensagem com Gemini
        const result = await processMessageWithGemini(message, {
            userAccounts: accounts,
            fixedBills: fixedBills,
            currentUser: currentUser,
            customUserName: customUserName
        });
        
        // ValidaÃ§Ã£o do resultado
        if (!result || typeof result !== 'object') {
            throw new Error('Resultado invÃ¡lido do processamento de mensagem');
        }
        
        // Processar resultado do Gemini
        await processGeminiResult(result, message);
    } catch (error) {
        console.error('Erro ao processar mensagem:', error);
        
        // Mensagem de erro mais amigÃ¡vel e inteligente
        let errorMessage = 'âŒ Desculpe, ocorreu um erro ao processar sua mensagem. ';
        
        if (error.message.includes('Valor deve ser maior que zero')) {
            errorMessage += 'Por favor, informe um valor vÃ¡lido maior que zero.';
        } else if (error.message.includes('Saldo insuficiente')) {
            errorMessage += 'Saldo insuficiente para realizar esta operaÃ§Ã£o.';
        } else if (error.message.includes('Conta nÃ£o encontrada')) {
            errorMessage += 'Conta nÃ£o encontrada. Verifique se a conta existe.';
        } else if (error.message.includes('UsuÃ¡rio nÃ£o autenticado')) {
            errorMessage += 'SessÃ£o expirada. FaÃ§a login novamente.';
        } else if (error.message.includes('Missing or insufficient permissions')) {
            errorMessage += 'Problema de permissÃµes no banco de dados. Tente recarregar a pÃ¡gina.';
        } else if (error.message.includes('Resultado invÃ¡lido')) {
            errorMessage += 'Erro interno do sistema. Tente reformular sua mensagem.';
        } else {
            errorMessage += 'Tente reformular sua mensagem ou verificar se todos os dados estÃ£o corretos.';
        }
        
        addChatMessage('assistant', errorMessage);
    }
}

// Executar aÃ§Ãµes do Firestore
async function executeAction(payload) {
    try {
        // ValidaÃ§Ã£o robusta do payload
        if (!payload || typeof payload !== 'object') {
            throw new Error('Payload invÃ¡lido');
        }
        
        if (!payload.action || typeof payload.action !== 'string') {
            throw new Error('AÃ§Ã£o invÃ¡lida no payload');
        }
        
        if (!payload.data || typeof payload.data !== 'object') {
            throw new Error('Dados invÃ¡lidos no payload');
        }
        
        switch (payload.action) {
            case 'ADD_TRANSACTION':
                // A data jÃ¡ vem como objeto Date do NLU, nÃ£o precisa converter
                // Se por algum motivo vier como string, converter preservando a data local
                if (payload.data.date && typeof payload.data.date === 'string') {
                    // Extrair componentes da data para evitar problemas de fuso horÃ¡rio
                    const dateStr = payload.data.date;
                    const dateMatch = dateStr.match(/(\d{4})-(\d{2})-(\d{2})/);
                    if (dateMatch) {
                        const [, year, month, day] = dateMatch;
                        payload.data.date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
                    } else {
                        payload.data.date = new Date(payload.data.date);
                    }
                }
                
                await addTransaction(payload.data);
                const account = accounts.find(acc => acc.id === payload.data.accountId);
                const emoji = payload.data.type === 'expense' ? 'ðŸ’¸' : 'ðŸ’°';
                const actionType = payload.data.type === 'expense' ? 'gasto' : 'receita';
                
                let message = `${emoji} **${actionType.charAt(0).toUpperCase() + actionType.slice(1)} registrado com sucesso!**\n\n` +
                    `ðŸ’° **Valor:** R$ ${payload.data.amount.toFixed(2)}\n` +
                    `ðŸ“ **DescriÃ§Ã£o:** ${payload.data.description}\n` +
                    `ðŸ¦ **Conta:** ${account?.name || 'N/A'}\n` +
                    `ðŸ“… **Data:** ${payload.data.date ? new Date(payload.data.date).toLocaleDateString('pt-BR') : new Date().toLocaleDateString('pt-BR')}`;
                
                // Adicionar informaÃ§Ã£o sobre pagamento parcial
                if (payload.data.isPartialPayment && payload.data.remainingAmount > 0) {
                    message += `\n\nâš ï¸ **Pagamento parcial:** Ainda restam R$ ${payload.data.remainingAmount.toFixed(2)} para pagar.`;
                }
                
                addChatMessage('assistant', message);
                break;
                
            case 'PAY_FIXED_BILL_CHAT':
                // ðŸ§  SISTEMA INTELIGENTE: Processar pagamento restante
                // Usar a funÃ§Ã£o especÃ­fica para pagamento de contas fixas
                const result = await payFixedBill(
                    payload.data.billId,
                    payload.data.paymentAmount,
                    payload.data.accountId,
                    payload.data.isFullPayment,
                    null, // targetPeriod
                    payload.data.isRemainingPayment
                );
                
                const billAccount = accounts.find(acc => acc.id === payload.data.accountId);
                const billEmoji = 'ðŸ’¸';
                const paymentType = payload.data.isRemainingPayment ? 'restante' : 
                                  (payload.data.isFullPayment ? 'completo' : 'parcial');
                
                let billMessage = `${billEmoji} **Gasto registrado com sucesso!**\n\n` +
                    `ðŸ’° **Valor:** R$ ${payload.data.paymentAmount.toFixed(2)}\n` +
                    `ðŸ“ **DescriÃ§Ã£o:** ${payload.data.billDescription} (pagamento ${paymentType})\n` +
                    `ðŸ¦ **Conta:** ${billAccount?.name || 'N/A'}\n` +
                    `ðŸ“… **Data:** ${new Date().toLocaleDateString('pt-BR')}`;
                
                // Adicionar informaÃ§Ã£o sobre pagamento parcial
                if (!payload.data.isFullPayment && !payload.data.isRemainingPayment && payload.data.remainingAmount > 0) {
                    billMessage += `\n\nâš ï¸ **Pagamento parcial:** Ainda restam R$ ${payload.data.remainingAmount.toFixed(2)} para pagar.`;
                }
                
                addChatMessage('assistant', billMessage);
                break;
                
            case 'PERFORM_TRANSFER':
                await performTransfer(payload.data.fromAccountId, payload.data.toAccountId, payload.data.amount);
                const fromAccount = accounts.find(acc => acc.id === payload.data.fromAccountId);
                const toAccount = accounts.find(acc => acc.id === payload.data.toAccountId);
                
                addChatMessage('assistant', 
                    `ðŸ”„ **TransferÃªncia realizada com sucesso!**\n\n` +
                    `ðŸ’° **Valor:** R$ ${payload.data.amount.toFixed(2)}\n` +
                    `ðŸ“¤ **De:** ${fromAccount?.name || 'N/A'}\n` +
                    `ðŸ“¥ **Para:** ${toAccount?.name || 'N/A'}\n` +
                    `ðŸ“… **Data:** ${new Date().toLocaleDateString('pt-BR')}`
                );
                break;
                
            case 'QUERY_SUMMARY':
                const summary = generateAdvancedSummary(payload.data);
                addChatMessage('assistant', summary);
                break;
                
            case 'QUERY_DAILY_EXPENSES':
                const dailyExpenses = generateDailyExpenses(payload.data);
                addChatMessage('assistant', dailyExpenses);
                break;
                
            case 'QUERY_DAILY_INCOME':
                const dailyIncome = generateDailyIncome(payload.data);
                addChatMessage('assistant', dailyIncome);
                break;
                
            case 'QUERY_DAILY_TRANSFERS':
                const dailyTransfers = generateDailyTransfers(payload.data);
                addChatMessage('assistant', dailyTransfers);
                break;
                
            case 'ANALYTICS':
                const analytics = generateAnalytics(payload.data);
                addChatMessage('assistant', analytics);
                break;
                
            case 'ADD_DEBT':
                await addDebt(payload.data);
                addChatMessage('assistant', 
                    `ðŸ’³ **DÃ­vida registrada com sucesso!**\n\n` +
                    `ðŸ’° **Valor:** R$ ${payload.data.amount.toFixed(2)}\n` +
                    `ðŸ‘¤ **Para:** ${payload.data.debtorName}\n` +
                    `ðŸ“ **DescriÃ§Ã£o:** ${payload.data.description}\n` +
                    `ðŸ“… **Data:** ${new Date().toLocaleDateString('pt-BR')}\n\n` +
                    `ðŸ’¡ **Dica:** Use "minhas dÃ­vidas" para consultar todas as suas dÃ­vidas pendentes.`
                );
                break;
                
            case 'QUERY_DEBTS':
                const debts = await queryDebts(payload.data);
                addChatMessage('assistant', debts);
                break;
                
            case 'MONTHLY_COMPARISON':
                try {
                    const comparison = await analyzeMonthlyComparison(payload.data.userId);
                    addChatMessage('assistant', comparison);
                } catch (error) {
                    console.error('Erro na comparaÃ§Ã£o mensal:', error);
                    addChatMessage('assistant', 'âŒ Erro ao gerar comparaÃ§Ã£o mensal. Tente novamente.');
                }
                break;
                
            case 'SAVINGS_SUGGESTIONS':
                try {
                    const suggestions = await generateSavingsSuggestions(payload.data.userId);
                    addChatMessage('assistant', suggestions);
                } catch (error) {
                    console.error('Erro nas sugestÃµes de economia:', error);
                    addChatMessage('assistant', 'âŒ Erro ao gerar sugestÃµes de economia. Tente novamente.');
                }
                break;
                
            default:
                addChatMessage('assistant', 'ðŸ¤” AÃ§Ã£o nÃ£o implementada ainda. Estou aprendendo novas funcionalidades!');
        }
    } catch (error) {
        console.error('Erro ao executar aÃ§Ã£o:', error);
        
        // Mensagem de erro mais especÃ­fica e inteligente
        let errorMessage = 'âŒ **Erro:** ';
        
        if (error.message.includes('Valor deve ser maior que zero')) {
            errorMessage += 'O valor deve ser maior que zero.';
        } else if (error.message.includes('Saldo insuficiente')) {
            errorMessage += 'Saldo insuficiente para realizar esta operaÃ§Ã£o.';
        } else if (error.message.includes('Conta nÃ£o encontrada')) {
            errorMessage += 'Conta nÃ£o encontrada.';
        } else if (error.message.includes('UsuÃ¡rio nÃ£o autenticado')) {
            errorMessage += 'SessÃ£o expirada. FaÃ§a login novamente.';
        } else if (error.message.includes('Missing or insufficient permissions')) {
            errorMessage += 'Problema de permissÃµes no banco de dados. Atualize as regras do Firestore ou recarregue a pÃ¡gina.';
        } else if (error.message.includes('Payload invÃ¡lido') || error.message.includes('AÃ§Ã£o invÃ¡lida') || error.message.includes('Dados invÃ¡lidos')) {
            errorMessage += 'Erro interno do sistema. Tente reformular sua mensagem.';
        } else {
            errorMessage += error.message;
        }
        
        addChatMessage('assistant', errorMessage);
    }
}

// Gerar resumo financeiro avanÃ§ado
function generateAdvancedSummary(data) {
    const currentMonth = new Date().getMonth();
    const currentYear = new Date().getFullYear();
    
    const monthTransactions = transactions.filter(t => {
        if (!t.date) return false;
        
        let transactionDate;
        try {
            if (t.date && typeof t.date.toDate === 'function') {
                transactionDate = t.date.toDate();
            } else if (t.date) {
                transactionDate = new Date(t.date);
            } else {
                return false;
            }
            
            if (isNaN(transactionDate.getTime())) {
                return false;
            }
            
            return transactionDate.getMonth() === currentMonth && 
                   transactionDate.getFullYear() === currentYear;
        } catch (error) {
            console.warn('Erro ao processar data da transaÃ§Ã£o:', error);
            return false;
        }
    });
    
    const income = monthTransactions
        .filter(t => t.type === 'income')
        .reduce((sum, t) => sum + t.amount, 0);
        
    const expenses = monthTransactions
        .filter(t => t.type === 'expense')
        .reduce((sum, t) => sum + t.amount, 0);
    
    const balance = income - expenses;
    const totalBalance = accounts.reduce((sum, acc) => sum + acc.balance, 0);
    
    // Calcular estatÃ­sticas por categoria
    const categoryStats = {};
    monthTransactions
        .filter(t => t.type === 'expense')
        .forEach(t => {
            const category = t.category || 'outros';
            categoryStats[category] = (categoryStats[category] || 0) + t.amount;
        });
    
    // Top 3 categorias de gastos
    const topCategories = Object.entries(categoryStats)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 3);
    
    let message = `ðŸ“Š **Resumo Financeiro do MÃªs**\n\n`;
    message += `ðŸ’° **Receitas:** R$ ${income.toFixed(2)}\n`;
    message += `ðŸ’¸ **Despesas:** R$ ${expenses.toFixed(2)}\n`;
    message += `ðŸ’µ **Saldo do MÃªs:** R$ ${balance.toFixed(2)}\n`;
    message += `ðŸ¦ **Saldo Total:** R$ ${totalBalance.toFixed(2)}\n\n`;
    
    if (topCategories.length > 0) {
        message += `ðŸ“ˆ **Top 3 Categorias de Gastos:**\n`;
        topCategories.forEach(([category, amount], index) => {
            const percentage = ((amount / expenses) * 100).toFixed(1);
            message += `${index + 1}. ${category}: R$ ${amount.toFixed(2)} (${percentage}%)\n`;
        });
        message += '\n';
    }
    
    // AnÃ¡lise de tendÃªncia
    if (balance > 0) {
        message += `âœ… **AnÃ¡lise:** VocÃª estÃ¡ com saldo positivo este mÃªs! ParabÃ©ns!`;
    } else if (balance < 0) {
        message += `âš ï¸ **AnÃ¡lise:** VocÃª estÃ¡ com saldo negativo. Considere revisar seus gastos.`;
    } else {
        message += `ðŸ“Š **AnÃ¡lise:** Seus gastos estÃ£o equilibrados com suas receitas.`;
    }
    
    return message;
}

// Gerar anÃ¡lise avanÃ§ada
function generateAnalytics(data) {
    const currentMonth = new Date().getMonth();
    const currentYear = new Date().getFullYear();
    
    const monthTransactions = transactions.filter(t => {
        if (!t.date) return false;
        
        let transactionDate;
        try {
            if (t.date && typeof t.date.toDate === 'function') {
                transactionDate = t.date.toDate();
            } else if (t.date) {
                transactionDate = new Date(t.date);
            } else {
                return false;
            }
            
            if (isNaN(transactionDate.getTime())) {
                return false;
            }
            
            return transactionDate.getMonth() === currentMonth && 
                   transactionDate.getFullYear() === currentYear;
        } catch (error) {
            return false;
        }
    });
    
    const expenses = monthTransactions.filter(t => t.type === 'expense');
    const income = monthTransactions.filter(t => t.type === 'income');
    
    // AnÃ¡lise por categoria
    const categoryAnalysis = {};
    expenses.forEach(t => {
        const category = t.category || 'outros';
        if (!categoryAnalysis[category]) {
            categoryAnalysis[category] = {
                total: 0,
                count: 0,
                avg: 0
            };
        }
        categoryAnalysis[category].total += t.amount;
        categoryAnalysis[category].count += 1;
    });
    
    // Calcular mÃ©dias
    Object.values(categoryAnalysis).forEach(cat => {
        cat.avg = cat.total / cat.count;
    });
    
    // Top categorias
    const topCategories = Object.entries(categoryAnalysis)
        .sort(([,a], [,b]) => b.total - a.total)
        .slice(0, 5);
    
    let message = `ðŸ“ˆ **AnÃ¡lise Detalhada dos Gastos**\n\n`;
    
    if (topCategories.length > 0) {
        message += `ðŸ† **Top 5 Categorias de Gastos:**\n`;
        topCategories.forEach(([category, stats], index) => {
            const percentage = ((stats.total / expenses.reduce((sum, t) => sum + t.amount, 0)) * 100).toFixed(1);
            message += `${index + 1}. **${category}**\n`;
            message += `   ðŸ’° Total: R$ ${stats.total.toFixed(2)}\n`;
            message += `   ðŸ“Š MÃ©dia: R$ ${stats.avg.toFixed(2)}\n`;
            message += `   ðŸ”¢ TransaÃ§Ãµes: ${stats.count}\n`;
            message += `   ðŸ“ˆ Percentual: ${percentage}%\n\n`;
        });
    }
    
    // AnÃ¡lise de receitas
    if (income.length > 0) {
        const totalIncome = income.reduce((sum, t) => sum + t.amount, 0);
        const avgIncome = totalIncome / income.length;
        
        message += `ðŸ’° **AnÃ¡lise de Receitas:**\n`;
        message += `ðŸ“Š Total: R$ ${totalIncome.toFixed(2)}\n`;
        message += `ðŸ“ˆ MÃ©dia por transaÃ§Ã£o: R$ ${avgIncome.toFixed(2)}\n`;
        message += `ðŸ”¢ NÃºmero de receitas: ${income.length}\n\n`;
    }
    
    // Insights
    message += `ðŸ’¡ **Insights:**\n`;
    
    if (topCategories.length > 0) {
        const biggestCategory = topCategories[0];
        message += `â€¢ Sua maior categoria de gastos Ã© **${biggestCategory[0]}** (${((biggestCategory[1].total / expenses.reduce((sum, t) => sum + t.amount, 0)) * 100).toFixed(1)}%)\n`;
    }
    
    const totalExpenses = expenses.reduce((sum, t) => sum + t.amount, 0);
    const totalIncome = income.reduce((sum, t) => sum + t.amount, 0);
    
    if (totalIncome > 0) {
        const savingsRate = ((totalIncome - totalExpenses) / totalIncome * 100).toFixed(1);
        message += `â€¢ Taxa de poupanÃ§a: ${savingsRate}%\n`;
    }
    
    if (expenses.length > 0) {
        const avgExpense = totalExpenses / expenses.length;
        message += `â€¢ Gasto mÃ©dio por transaÃ§Ã£o: R$ ${avgExpense.toFixed(2)}\n`;
    }
    
    return message;
}

// Gerar relatÃ³rio de gastos diÃ¡rios
function generateDailyExpenses(data) {
    const targetDate = data.date;
    const targetDateStr = targetDate.toLocaleDateString('pt-BR');
    const isToday = targetDate.toDateString() === new Date().toDateString();
    const isYesterday = targetDate.toDateString() === new Date(Date.now() - 24 * 60 * 60 * 1000).toDateString();
    
    let periodText = '';
    if (isToday) {
        periodText = 'hoje';
    } else if (isYesterday) {
        periodText = 'ontem';
    } else {
        periodText = `em ${targetDateStr}`;
    }
    
    // Filtrar transaÃ§Ãµes do dia especÃ­fico
    const dayTransactions = transactions.filter(t => {
        if (!t.date) return false;
        
        let transactionDate;
        try {
            if (t.date && typeof t.date.toDate === 'function') {
                transactionDate = t.date.toDate();
            } else if (t.date) {
                transactionDate = new Date(t.date);
            } else {
                return false;
            }
            
            if (isNaN(transactionDate.getTime())) {
                return false;
            }
            
            return transactionDate.toDateString() === targetDate.toDateString();
        } catch (error) {
            return false;
        }
    });
    
    // Filtrar apenas gastos
    const expenses = dayTransactions.filter(t => t.type === 'expense');
    const totalExpenses = expenses.reduce((sum, t) => sum + t.amount, 0);
    
    let message = `ðŸ’¸ **Gastos ${periodText.charAt(0).toUpperCase() + periodText.slice(1)}**\n\n`;
    
    if (expenses.length === 0) {
        message += `âœ… **Nenhum gasto registrado ${periodText}!**\n\n`;
        message += `ðŸŽ‰ ParabÃ©ns! VocÃª nÃ£o gastou nada ${periodText}.`;
        return message;
    }
    
    message += `ðŸ’° **Total gasto:** R$ ${totalExpenses.toFixed(2)}\n`;
    message += `ðŸ“Š **NÃºmero de gastos:** ${expenses.length}\n\n`;
    
    // Listar gastos por categoria
    const categoryGroups = {};
    expenses.forEach(expense => {
        const category = expense.category || 'outros';
        if (!categoryGroups[category]) {
            categoryGroups[category] = [];
        }
        categoryGroups[category].push(expense);
    });
    
    message += `ðŸ“‹ **Detalhamento por categoria:**\n\n`;
    
    Object.entries(categoryGroups).forEach(([category, categoryExpenses]) => {
        const categoryTotal = categoryExpenses.reduce((sum, t) => sum + t.amount, 0);
        const percentage = ((categoryTotal / totalExpenses) * 100).toFixed(1);
        
        message += `ðŸ·ï¸ **${category.charAt(0).toUpperCase() + category.slice(1)}**\n`;
        message += `   ðŸ’° Total: R$ ${categoryTotal.toFixed(2)} (${percentage}%)\n`;
        message += `   ðŸ”¢ TransaÃ§Ãµes: ${categoryExpenses.length}\n`;
        
        // Listar transaÃ§Ãµes individuais
        categoryExpenses.forEach(expense => {
            const time = expense.date && typeof expense.date.toDate === 'function' 
                ? expense.date.toDate().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })
                : 'N/A';
            message += `   â€¢ R$ ${expense.amount.toFixed(2)} - ${expense.description} (${time})\n`;
        });
        message += '\n';
    });
    
    // AnÃ¡lise rÃ¡pida
    if (totalExpenses > 0) {
        const avgExpense = totalExpenses / expenses.length;
        message += `ðŸ“ˆ **AnÃ¡lise:**\n`;
        message += `â€¢ Gasto mÃ©dio por transaÃ§Ã£o: R$ ${avgExpense.toFixed(2)}\n`;
        
        if (expenses.length === 1) {
            message += `â€¢ VocÃª fez apenas 1 gasto ${periodText}\n`;
        } else {
            message += `â€¢ VocÃª fez ${expenses.length} gastos ${periodText}\n`;
        }
    }
    
    return message;
}

// Gerar relatÃ³rio de receitas diÃ¡rias
function generateDailyIncome(data) {
    const targetDate = data.date;
    const targetDateStr = targetDate.toLocaleDateString('pt-BR');
    const isToday = targetDate.toDateString() === new Date().toDateString();
    const isYesterday = targetDate.toDateString() === new Date(Date.now() - 24 * 60 * 60 * 1000).toDateString();
    
    let periodText = '';
    if (isToday) {
        periodText = 'hoje';
    } else if (isYesterday) {
        periodText = 'ontem';
    } else {
        periodText = `em ${targetDateStr}`;
    }
    
    // Filtrar transaÃ§Ãµes do dia especÃ­fico
    const dayTransactions = transactions.filter(t => {
        if (!t.date) return false;
        
        let transactionDate;
        try {
            if (t.date && typeof t.date.toDate === 'function') {
                transactionDate = t.date.toDate();
            } else if (t.date) {
                transactionDate = new Date(t.date);
            } else {
                return false;
            }
            
            if (isNaN(transactionDate.getTime())) {
                return false;
            }
            
            return transactionDate.toDateString() === targetDate.toDateString();
        } catch (error) {
            return false;
        }
    });
    
    // Filtrar apenas receitas
    const income = dayTransactions.filter(t => t.type === 'income');
    const totalIncome = income.reduce((sum, t) => sum + t.amount, 0);
    
    let message = `ðŸ’° **Receitas ${periodText.charAt(0).toUpperCase() + periodText.slice(1)}**\n\n`;
    
    if (income.length === 0) {
        message += `ðŸ“‰ **Nenhuma receita registrada ${periodText}!**\n\n`;
        message += `ðŸ’¡ VocÃª nÃ£o recebeu nenhum dinheiro ${periodText}.`;
        return message;
    }
    
    message += `ðŸ’µ **Total recebido:** R$ ${totalIncome.toFixed(2)}\n`;
    message += `ðŸ“Š **NÃºmero de receitas:** ${income.length}\n\n`;
    
    // Listar receitas por categoria
    const categoryGroups = {};
    income.forEach(incomeItem => {
        const category = incomeItem.category || 'outros';
        if (!categoryGroups[category]) {
            categoryGroups[category] = [];
        }
        categoryGroups[category].push(incomeItem);
    });
    
    message += `ðŸ“‹ **Detalhamento por categoria:**\n\n`;
    
    Object.entries(categoryGroups).forEach(([category, categoryIncome]) => {
        const categoryTotal = categoryIncome.reduce((sum, t) => sum + t.amount, 0);
        const percentage = ((categoryTotal / totalIncome) * 100).toFixed(1);
        
        message += `ðŸ·ï¸ **${category.charAt(0).toUpperCase() + category.slice(1)}**\n`;
        message += `   ðŸ’° Total: R$ ${categoryTotal.toFixed(2)} (${percentage}%)\n`;
        message += `   ðŸ”¢ TransaÃ§Ãµes: ${categoryIncome.length}\n`;
        
        // Listar transaÃ§Ãµes individuais
        categoryIncome.forEach(incomeItem => {
            const time = incomeItem.date && typeof incomeItem.date.toDate === 'function' 
                ? incomeItem.date.toDate().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })
                : 'N/A';
            message += `   â€¢ R$ ${incomeItem.amount.toFixed(2)} - ${incomeItem.description} (${time})\n`;
        });
        message += '\n';
    });
    
    // AnÃ¡lise rÃ¡pida
    if (totalIncome > 0) {
        const avgIncome = totalIncome / income.length;
        message += `ðŸ“ˆ **AnÃ¡lise:**\n`;
        message += `â€¢ Receita mÃ©dia por transaÃ§Ã£o: R$ ${avgIncome.toFixed(2)}\n`;
        
        if (income.length === 1) {
            message += `â€¢ VocÃª recebeu apenas 1 entrada ${periodText}\n`;
        } else {
            message += `â€¢ VocÃª recebeu ${income.length} entradas ${periodText}\n`;
        }
    }
    
    return message;
}

// Gerar relatÃ³rio de transferÃªncias diÃ¡rias
function generateDailyTransfers(data) {
    const targetDate = data.date;
    const targetDateStr = targetDate.toLocaleDateString('pt-BR');
    const isToday = targetDate.toDateString() === new Date().toDateString();
    const isYesterday = targetDate.toDateString() === new Date(Date.now() - 24 * 60 * 60 * 1000).toDateString();
    
    let periodText = '';
    if (isToday) {
        periodText = 'hoje';
    } else if (isYesterday) {
        periodText = 'ontem';
    } else {
        periodText = `em ${targetDateStr}`;
    }
    
    // Filtrar transaÃ§Ãµes do dia especÃ­fico
    const dayTransactions = transactions.filter(t => {
        if (!t.date) return false;
        
        let transactionDate;
        try {
            if (t.date && typeof t.date.toDate === 'function') {
                transactionDate = t.date.toDate();
            } else if (t.date) {
                transactionDate = new Date(t.date);
            } else {
                return false;
            }
            
            if (isNaN(transactionDate.getTime())) {
                return false;
            }
            
            return transactionDate.toDateString() === targetDate.toDateString();
        } catch (error) {
            return false;
        }
    });
    
    // Filtrar apenas transferÃªncias
    const transfers = dayTransactions.filter(t => t.type === 'transfer');
    
    let message = `ðŸ”„ **TransferÃªncias ${periodText.charAt(0).toUpperCase() + periodText.slice(1)}**\n\n`;
    
    if (transfers.length === 0) {
        message += `ðŸ“­ **Nenhuma transferÃªncia realizada ${periodText}!**\n\n`;
        message += `ðŸ’¡ VocÃª nÃ£o fez nenhuma transferÃªncia entre suas contas ${periodText}.`;
        return message;
    }
    
    message += `ðŸ“Š **NÃºmero de transferÃªncias:** ${transfers.length}\n\n`;
    
    // Listar transferÃªncias
    message += `ðŸ“‹ **Detalhamento das transferÃªncias:**\n\n`;
    
    transfers.forEach((transfer, index) => {
        const fromAccount = accounts.find(acc => acc.id === transfer.fromAccountId);
        const toAccount = accounts.find(acc => acc.id === transfer.toAccountId);
        const time = transfer.date && typeof transfer.date.toDate === 'function' 
            ? transfer.date.toDate().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })
            : 'N/A';
        
        message += `${index + 1}. **R$ ${transfer.amount.toFixed(2)}**\n`;
        message += `   ðŸ“¤ **De:** ${fromAccount?.name || 'Conta nÃ£o encontrada'}\n`;
        message += `   ðŸ“¥ **Para:** ${toAccount?.name || 'Conta nÃ£o encontrada'}\n`;
        message += `   ðŸ• **HorÃ¡rio:** ${time}\n`;
        if (transfer.description) {
            message += `   ðŸ“ **DescriÃ§Ã£o:** ${transfer.description}\n`;
        }
        message += '\n';
    });
    
    // AnÃ¡lise rÃ¡pida
    if (transfers.length > 0) {
        const totalTransferred = transfers.reduce((sum, t) => sum + t.amount, 0);
        const avgTransfer = totalTransferred / transfers.length;
        
        message += `ðŸ“ˆ **AnÃ¡lise:**\n`;
        message += `â€¢ Valor total transferido: R$ ${totalTransferred.toFixed(2)}\n`;
        message += `â€¢ Valor mÃ©dio por transferÃªncia: R$ ${avgTransfer.toFixed(2)}\n`;
        
        if (transfers.length === 1) {
            message += `â€¢ VocÃª fez apenas 1 transferÃªncia ${periodText}\n`;
        } else {
            message += `â€¢ VocÃª fez ${transfers.length} transferÃªncias ${periodText}\n`;
        }
    }
    
    return message;
}

// RenderizaÃ§Ã£o da UI
function renderAccounts() {
    accountsList.innerHTML = '';
    
    if (!accounts || accounts.length === 0) {
        accountsList.innerHTML = '<p class="text-gray-400 text-sm">Nenhuma conta cadastrada</p>';
        return;
    }
    
    accounts.forEach(account => {
        const accountElement = document.createElement('div');
        accountElement.className = 'account-card';
        accountElement.innerHTML = `
            <div class="flex justify-between items-center">
                <span class="text-gray-300">${account.name || 'Conta sem nome'}</span>
                <span class="account-balance ${(account.balance || 0) >= 0 ? 'positive' : 'negative'}">
                    R$ ${(account.balance || 0).toFixed(2)}
                </span>
            </div>
        `;
        accountsList.appendChild(accountElement);
    });
}

function renderAccountsManagement() {
    const accountsManagementList = document.getElementById('accounts-management-list');
    accountsManagementList.innerHTML = '';
    
    if (!accounts || accounts.length === 0) {
        accountsManagementList.innerHTML = '<p class="text-gray-400 text-sm">Nenhuma conta cadastrada</p>';
        return;
    }
    
    accounts.forEach(account => {
        const accountElement = document.createElement('div');
        accountElement.className = 'flex justify-between items-center p-3 bg-gray-700 rounded-lg';
        accountElement.innerHTML = `
            <div>
                <span class="text-gray-200 font-medium">${account.name}</span>
                <div class="text-sm text-gray-400">Saldo: R$ ${account.balance.toFixed(2)}</div>
            </div>
            <div class="flex space-x-2">
                <button class="edit-account-btn text-blue-400 hover:text-blue-300 text-sm" data-id="${account.id}">
                    Editar
                </button>
                <button class="delete-account-btn text-red-400 hover:text-red-300 text-sm" data-id="${account.id}">
                    Excluir
                </button>
            </div>
        `;
        
        // Adicionar event listeners
        accountElement.querySelector('.edit-account-btn').addEventListener('click', () => {
            editAccount(account);
        });
        accountElement.querySelector('.delete-account-btn').addEventListener('click', () => {
            showConfirmModal('Excluir Conta', `Tem certeza que deseja excluir a conta "${account.name}"?`, () => deleteAccount(account.id));
        });
        
        accountsManagementList.appendChild(accountElement);
    });
}

function renderFixedBills() {
    fixedBillsSection.innerHTML = '';
    
    if (!fixedBills || fixedBills.length === 0) {
        fixedBillsSection.innerHTML = '<p class="text-gray-400 text-sm">Nenhuma conta fixa cadastrada</p>';
        return;
    }
    
    // Ordenar por valor (mais caras primeiro) e pegar as top 3
    const topBills = [...fixedBills]
        .sort((a, b) => (b.amount || 0) - (a.amount || 0))
        .slice(0, 3);
    
    topBills.forEach(bill => {
        const billElement = document.createElement('div');
        billElement.className = 'fixed-bill-item';
        
        // Usar status calculado pelo Firebase se disponÃ­vel, senÃ£o calcular localmente
        let status, statusClass, statusText, totalPaid, remainingAmount;
        
        if (bill.status) {
            // Status jÃ¡ calculado pelo Firebase
            status = bill.status;
            statusClass = bill.statusClass;
            statusText = bill.statusText;
            totalPaid = bill.totalPaid || 0;
            remainingAmount = bill.remainingAmount || 0;
        } else {
            // Calcular status localmente (fallback)
            status = calculateBillStatus(bill);
            statusClass = getStatusClass(status);
            statusText = getStatusText(status);
            
            // Calcular valores pagos
            const billTransactions = transactions.filter(t => 
                t.billId === bill.id && 
                t.type === 'expense' &&
                (t.isPartialPayment || t.isBillPayment)
            );
            totalPaid = billTransactions.reduce((sum, t) => sum + t.amount, 0);
            remainingAmount = bill.amount - totalPaid;
        }
        
        billElement.innerHTML = `
            <div class="flex justify-between items-center">
                <span class="text-gray-300">${bill.description || bill.name || 'Conta sem nome'}</span>
                <span class="text-warning">R$ ${(bill.amount || 0).toFixed(2)}</span>
            </div>
            <div class="flex justify-between items-center text-sm">
                <span class="text-gray-400">Vencimento: dia ${bill.dueDay || 'N/A'}</span>
                ${remainingAmount > 0 ? `<span class="${statusClass}">${statusText}</span>` : `<span class="text-green-400 bg-green-900 bg-opacity-30 px-2 py-1 rounded-full text-xs">âœ“ Paga</span>`}
            </div>
        `;
        fixedBillsSection.appendChild(billElement);
    });
}

function renderBillsManagement() {
    const billsManagementList = document.getElementById('bills-management-list');
    billsManagementList.innerHTML = '';
    
    if (!fixedBills || fixedBills.length === 0) {
        billsManagementList.innerHTML = '<p class="text-gray-400 text-sm">Nenhuma conta fixa cadastrada</p>';
        return;
    }
    
    fixedBills.forEach(bill => {
        const billElement = document.createElement('div');
        billElement.className = 'flex justify-between items-center p-3 bg-gray-700 rounded-lg';
        billElement.innerHTML = `
            <div>
                <span class="text-gray-200 font-medium">${bill.description || bill.name}</span>
                <div class="text-sm text-gray-400">R$ ${bill.amount.toFixed(2)} - Vencimento: dia ${bill.dueDay}</div>
            </div>
            <div class="flex space-x-2">
                <button class="edit-bill-btn text-blue-400 hover:text-blue-300 text-sm" data-id="${bill.id}">
                    Editar
                </button>
                <button class="delete-bill-btn text-red-400 hover:text-red-300 text-sm" data-id="${bill.id}">
                    Excluir
                </button>
            </div>
        `;
        
        // Adicionar event listeners
        billElement.querySelector('.edit-bill-btn').addEventListener('click', () => {
            editBill(bill);
        });
        billElement.querySelector('.delete-bill-btn').addEventListener('click', () => {
            showConfirmModal('Excluir Conta Fixa', `Tem certeza que deseja excluir a conta fixa "${bill.description || bill.name}"?`, () => deleteFixedBill(bill.id));
        });
        
        billsManagementList.appendChild(billElement);
    });
}

function renderBillsView() {
    billsViewList.innerHTML = '';
    
    if (!filteredBills || filteredBills.length === 0) {
        billsViewList.innerHTML = '<p class="text-gray-400 text-center py-8">Nenhuma conta fixa encontrada</p>';
        return;
    }
    
    // Ordenar por prioridade: vencidas primeiro, depois vence hoje, depois quase vencendo, depois pendentes
    const sortedBills = [...filteredBills].sort((a, b) => {
        const statusA = calculateBillStatus(a);
        const statusB = calculateBillStatus(b);
        
        const priorityOrder = ['overdue', 'due-today', 'due-soon', 'pending', 'partial', 'paid'];
        const priorityA = priorityOrder.indexOf(statusA);
        const priorityB = priorityOrder.indexOf(statusB);
        
        if (priorityA !== priorityB) {
            return priorityA - priorityB;
        }
        
        // Se mesmo status, ordenar por valor (mais caras primeiro)
        return (b.amount || 0) - (a.amount || 0);
    });
    
    sortedBills.forEach(bill => {
        const billElement = document.createElement('div');
        billElement.className = 'bg-gray-700 rounded-lg p-4 mb-4';
        
        // Usar status calculado pelo Firebase se disponÃ­vel, senÃ£o calcular localmente
        let status, statusClass, statusText, totalPaid, remainingAmount, canPay;
        
        if (bill.status) {
            // Status jÃ¡ calculado pelo Firebase
            status = bill.status;
            statusClass = bill.statusClass;
            statusText = bill.statusText;
            totalPaid = bill.totalPaid || 0;
            remainingAmount = bill.remainingAmount || 0;
            canPay = bill.canPay !== false; // Sempre true quando hÃ¡ valor restante
        } else {
            // Calcular status localmente (fallback)
            status = calculateBillStatus(bill);
            statusClass = getStatusClass(status);
            statusText = getStatusText(status);
            
            // Calcular valores pagos
            const billTransactions = transactions.filter(t => 
                t.billId === bill.id && 
                t.type === 'expense' &&
                (t.isPartialPayment || t.isBillPayment)
            );
            totalPaid = billTransactions.reduce((sum, t) => sum + t.amount, 0);
            remainingAmount = bill.amount - totalPaid;
            canPay = true; // Sempre pode pagar quando hÃ¡ valor restante
        }
        
        // Determinar texto do botÃ£o de pagamento
        let paymentButtonText = 'Pagar';
        if (remainingAmount > 0) {
            if (status === 'overdue') {
                paymentButtonText = 'Pagar Vencida';
            } else if (status === 'partial') {
                paymentButtonText = 'Completar Pagamento';
            } else if (status === 'due-soon') {
                paymentButtonText = 'Pagar Antecipado';
            } else {
                paymentButtonText = 'Pagar';
            }
        } else {
            paymentButtonText = 'Pagar PrÃ³ximo';
        }
        
        // Obter Ãºltimo perÃ­odo pago para mostrar
        const lastPaidPeriod = bill.lastPaidPeriod;
        const lastPaidText = lastPaidPeriod ? 
            `Ãšltimo pago: ${lastPaidPeriod.monthName} ${lastPaidPeriod.year}` : 
            'Nenhum pagamento';
        
        billElement.innerHTML = `
            <div class="flex justify-between items-start mb-3">
                <div>
                    <h4 class="text-lg font-medium text-white">${bill.description || bill.name}</h4>
                    <div class="text-sm text-gray-400 mt-1">
                        <span>Valor: R$ ${bill.amount.toFixed(2)}</span>
                        <span class="mx-2">â€¢</span>
                        <span>Vencimento: dia ${bill.dueDay}</span>
                        <span class="mx-2">â€¢</span>
                        <span>Categoria: ${getCategoryName(bill.category)}</span>
                    </div>
                </div>
                <div class="flex space-x-2">
                    <button class="edit-bill-btn text-blue-400 hover:text-blue-300 text-sm px-2 py-1 rounded" data-id="${bill.id}">
                        âœï¸ Editar
                    </button>
                    <button class="delete-bill-btn text-red-400 hover:text-red-300 text-sm px-2 py-1 rounded" data-id="${bill.id}">
                        ðŸ—‘ï¸ Excluir
                    </button>
                </div>
            </div>
            
            <div class="flex justify-between items-center mb-3">
                <div class="flex items-center space-x-4">
                    <span class="${statusClass} font-medium">${statusText}</span>
                    <span class="text-gray-400 text-sm">${lastPaidText}</span>
                </div>
                <div class="text-right">
                    <div class="text-sm text-gray-400">
                        Pago: R$ ${totalPaid.toFixed(2)}
                    </div>
                    <div class="text-sm ${remainingAmount > 0 ? 'text-red-400' : 'text-green-400'}">
                        Restante: R$ ${remainingAmount.toFixed(2)}
                    </div>
                </div>
            </div>
            
            <div class="flex justify-between items-center">
                <div class="flex space-x-2">
                    <button class="pay-bill-btn bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md transition duration-200 text-sm" data-id="${bill.id}">
                        ${paymentButtonText}
                    </button>
                    <button class="pay-partial-btn bg-yellow-600 hover:bg-yellow-700 text-white px-4 py-2 rounded-md transition duration-200 text-sm" data-id="${bill.id}">
                        Pagamento Parcial
                    </button>
                    <button class="view-history-btn bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md transition duration-200 text-sm" data-id="${bill.id}">
                        ðŸ“Š HistÃ³rico
                    </button>
                </div>
                <div class="text-xs text-gray-500">
                    ID: ${bill.id.substring(0, 8)}...
                </div>
            </div>
        `;
        
        // Adicionar event listeners
        billElement.querySelector('.edit-bill-btn').addEventListener('click', () => {
            editBill(bill);
        });
        
        billElement.querySelector('.delete-bill-btn').addEventListener('click', () => {
            showConfirmModal('Excluir Conta Fixa', `Tem certeza que deseja excluir a conta fixa "${bill.description || bill.name}"?`, () => deleteFixedBill(bill.id));
        });
        
        billElement.querySelector('.pay-bill-btn').addEventListener('click', () => {
            handleFullPaymentModal(bill);
        });
        
        billElement.querySelector('.pay-partial-btn').addEventListener('click', () => {
            handlePartialPaymentModal(bill);
        });
        
        billElement.querySelector('.view-history-btn').addEventListener('click', () => {
            showPaymentHistory(bill.id);
        });
        
        billsViewList.appendChild(billElement);
    });
}

// FunÃ§Ã£o para agrupar transferÃªncias e evitar duplicaÃ§Ã£o no histÃ³rico
function groupTransferTransactions(transactions) {
    const grouped = [];
    const processedTransferIds = new Set();
    
    transactions.forEach(transaction => {
        // Se Ã© uma transferÃªncia que jÃ¡ foi processada, pular
        if (transaction.transferId && processedTransferIds.has(transaction.transferId)) {
            return;
        }
        
        // Se Ã© uma transferÃªncia de entrada (transfer_in), criar uma entrada Ãºnica
        if (transaction.type === 'transfer_in') {
            processedTransferIds.add(transaction.transferId);
            
            // Encontrar a transaÃ§Ã£o de saÃ­da correspondente
            const outTransaction = transactions.find(t => 
                t.transferId === transaction.transferId && t.type === 'transfer_out'
            );
            
            if (outTransaction) {
                // Criar uma entrada Ãºnica para a transferÃªncia
                grouped.push({
                    ...transaction,
                    description: `TransferÃªncia de ${outTransaction.accountName} para ${transaction.accountName}`,
                    type: 'transfer',
                    amount: transaction.amount
                });
            } else {
                // Se nÃ£o encontrar a transaÃ§Ã£o de saÃ­da, usar a entrada
                grouped.push(transaction);
            }
        }
        // Se Ã© uma transferÃªncia de saÃ­da (transfer_out), pular (jÃ¡ foi processada acima)
        else if (transaction.type === 'transfer_out') {
            // NÃ£o adicionar, pois serÃ¡ processada junto com a entrada
            return;
        }
        // Para outros tipos de transaÃ§Ã£o, adicionar normalmente
        else {
            grouped.push(transaction);
        }
    });
    
    // Ordenar por data (mais recente primeiro)
    return grouped.sort((a, b) => {
        const dateA = a.date?.toDate ? a.date.toDate() : new Date(a.date);
        const dateB = b.date?.toDate ? b.date.toDate() : new Date(b.date);
        return dateB - dateA;
    });
}

function renderRecentTransactions() {
    console.log('ðŸŽ¨ Renderizando transaÃ§Ãµes recentes...');
    
    if (!recentTransactions) {
        console.error('âŒ Elemento recentTransactions nÃ£o encontrado!');
        return;
    }
    
    recentTransactions.innerHTML = '';
    
    if (!transactions || transactions.length === 0) {
        console.log('âš ï¸ Nenhuma transaÃ§Ã£o encontrada');
        recentTransactions.innerHTML = '<p class="text-gray-400 text-sm">Nenhuma transaÃ§Ã£o recente</p>';
        return;
    }
    
    // Agrupar transferÃªncias para evitar duplicaÃ§Ã£o
    const groupedTransactions = groupTransferTransactions(transactions);
    const recent = groupedTransactions.slice(0, 5);
    console.log('ðŸ“„ TransaÃ§Ãµes recentes para exibir:', recent.length);
    
    recent.forEach((transaction, index) => {
        console.log(`ðŸ’³ Renderizando transaÃ§Ã£o ${index + 1}:`, {
            id: transaction.id,
            description: transaction.description,
            amount: transaction.amount,
            type: transaction.type,
            accountName: transaction.accountName,
            date: transaction.date
        });
        
        const transactionElement = document.createElement('div');
        transactionElement.className = 'text-sm';
        
        const amount = transaction.amount || 0;
        const isExpense = transaction.type === 'expense';
        const amountClass = isExpense ? 'text-red-400' : 'text-green-400';
        const amountPrefix = isExpense ? '-' : '+';
        
        const html = `
            <div class="flex justify-between items-center">
                <span class="text-gray-300 truncate">${transaction.description || 'Sem descriÃ§Ã£o'}</span>
                <span class="${amountClass} font-medium">${amountPrefix}R$ ${amount.toFixed(2)}</span>
            </div>
            <div class="text-xs text-gray-400">${transaction.accountName || 'Conta nÃ£o especificada'} â€¢ ${formatDate(transaction.date)}</div>
        `;
        
        console.log(`ðŸ“ HTML gerado para transaÃ§Ã£o ${index + 1}:`, html);
        transactionElement.innerHTML = html;
        recentTransactions.appendChild(transactionElement);
    });
    
}

function renderTransactions() {
    console.log('ðŸŽ¨ Renderizando transaÃ§Ãµes no modal...');
    
    transactionsList.innerHTML = '';
    
    if (!filteredTransactions || filteredTransactions.length === 0) {
        console.log('âš ï¸ Nenhuma transaÃ§Ã£o filtrada encontrada');
        transactionsList.innerHTML = '<p class="text-gray-400 text-center py-8">Nenhuma transaÃ§Ã£o encontrada</p>';
        return;
    }
    
    // Agrupar transferÃªncias para evitar duplicaÃ§Ã£o
    const groupedFilteredTransactions = groupTransferTransactions(filteredTransactions);
    
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const pageTransactions = groupedFilteredTransactions.slice(startIndex, endIndex);
    
    console.log('ðŸ“„ TransaÃ§Ãµes da pÃ¡gina atual:', pageTransactions.length);
    
    // Criar container com altura fixa e scroll
    const container = document.createElement('div');
    container.className = 'h-96 overflow-y-auto space-y-2 pr-2'; // Altura fixa com scroll
    
    pageTransactions.forEach((transaction, index) => {
        console.log(`ðŸ’³ Renderizando transaÃ§Ã£o ${index + 1} no modal:`, {
            id: transaction.id,
            description: transaction.description,
            amount: transaction.amount,
            type: transaction.type
        });
        
        const transactionElement = document.createElement('div');
        transactionElement.className = 'flex justify-between items-center p-3 bg-gray-700 rounded-lg hover:bg-gray-600 transition-colors';
        
        const amount = transaction.amount || 0;
        const isExpense = transaction.type === 'expense';
        const amountClass = isExpense ? 'text-red-400' : 'text-green-400';
        const amountPrefix = isExpense ? '-' : '+';
        
        transactionElement.innerHTML = `
            <div class="flex-1">
                <div class="text-gray-200 font-medium">${transaction.description || 'Sem descriÃ§Ã£o'}</div>
                <div class="text-sm text-gray-400">${transaction.accountName || 'Conta nÃ£o especificada'} â€¢ ${formatDate(transaction.date)}</div>
            </div>
            <div class="text-right">
                <div class="${amountClass} font-medium">${amountPrefix}R$ ${amount.toFixed(2)}</div>
                <div class="text-xs text-gray-400">${getTransactionTypeLabel(transaction.type)}</div>
            </div>
            <div class="ml-3">
                <button onclick="handleRefund('${transaction.id}')" class="refund-btn text-xs">
                    Estornar
                </button>
            </div>
        `;
        container.appendChild(transactionElement);
    });
    
    // Adicionar botÃ£o "Carregar Mais" se necessÃ¡rio
    if (hasMoreTransactions && currentPage * itemsPerPage >= filteredTransactions.length) {
        const loadMoreButton = document.createElement('div');
        loadMoreButton.className = 'text-center py-4';
        loadMoreButton.innerHTML = `
            <button onclick="loadMoreTransactions()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded">
                ðŸ“„ Carregar Mais TransaÃ§Ãµes
            </button>
        `;
        container.appendChild(loadMoreButton);
    }
    
    transactionsList.appendChild(container);
    
    
    updatePagination();
}

function updatePagination() {
    const total = filteredTransactions.length;
    const start = (currentPage - 1) * itemsPerPage + 1;
    const end = Math.min(currentPage * itemsPerPage, total);
    
    document.getElementById('transactions-start').textContent = start;
    document.getElementById('transactions-end').textContent = end;
    document.getElementById('transactions-total').textContent = total;
    
    prevPageBtn.disabled = currentPage === 1;
    nextPageBtn.disabled = end >= total;
}

// FunÃ§Ã£o otimizada para renderizar transaÃ§Ãµes com scroll virtual
function renderTransactionsOptimized() {
    console.log('ðŸŽ¨ Renderizando transaÃ§Ãµes otimizadas...');
    
    transactionsList.innerHTML = '';
    
    if (!filteredTransactions || filteredTransactions.length === 0) {
        console.log('âš ï¸ Nenhuma transaÃ§Ã£o filtrada encontrada');
        transactionsList.innerHTML = '<p class="text-gray-400 text-center py-8">Nenhuma transaÃ§Ã£o encontrada</p>';
        return;
    }
    
    // Criar container com altura fixa e scroll
    const container = document.createElement('div');
    container.className = 'h-96 overflow-y-auto space-y-2 pr-2'; // Altura fixa com scroll
    
    // Renderizar apenas as transaÃ§Ãµes visÃ­veis (primeira pÃ¡gina)
    // Agrupar transferÃªncias para evitar duplicaÃ§Ã£o
    const groupedFilteredTransactions = groupTransferTransactions(filteredTransactions);
    
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const pageTransactions = groupedFilteredTransactions.slice(startIndex, endIndex);
    
    console.log(`ðŸ“„ Renderizando ${pageTransactions.length} transaÃ§Ãµes (pÃ¡gina ${currentPage})`);
    
    pageTransactions.forEach(transaction => {
        const transactionElement = document.createElement('div');
        transactionElement.className = 'bg-gray-700 rounded-lg p-4 hover:bg-gray-600 transition-colors';
        
        const date = transaction.date?.toDate ? transaction.date.toDate() : new Date(transaction.date);
        const formattedDate = date.toLocaleDateString('pt-BR');
        const formattedTime = date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
        
        const amountClass = transaction.type === 'income' ? 'text-green-400' : 'text-red-400';
        const amountPrefix = transaction.type === 'income' ? '+' : '-';
        
        transactionElement.innerHTML = `
            <div class="flex justify-between items-start">
                <div class="flex-1">
                    <div class="flex items-center space-x-2">
                        <span class="text-sm text-gray-400">${formattedDate}</span>
                        <span class="text-xs text-gray-500">${formattedTime}</span>
                    </div>
                    <h4 class="font-medium text-gray-200 mt-1">${transaction.description}</h4>
                    <p class="text-sm text-gray-400">${transaction.accountName}</p>
                    <span class="inline-block bg-gray-600 text-gray-300 text-xs px-2 py-1 rounded mt-2">
                        ${transaction.category || 'outros'}
                    </span>
                </div>
                <div class="text-right">
                    <div class="${amountClass} font-semibold text-lg">
                        ${amountPrefix}R$ ${transaction.amount.toFixed(2)}
                    </div>
                    <button onclick="handleRefund('${transaction.id}')" 
                            class="text-red-400 hover:text-red-300 text-sm mt-1">
                        Estornar
                    </button>
                </div>
            </div>
        `;
        
        container.appendChild(transactionElement);
    });
    
    // Adicionar botÃ£o "Carregar Mais" se necessÃ¡rio
    if (hasMoreTransactions && !isLoadingMore) {
        const loadMoreButton = document.createElement('div');
        loadMoreButton.className = 'text-center py-4';
        loadMoreButton.innerHTML = `
            <button onclick="loadMoreTransactions()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded transition-colors">
                ðŸ“„ Carregar Mais TransaÃ§Ãµes
            </button>
        `;
        container.appendChild(loadMoreButton);
    }
    
    transactionsList.appendChild(container);
    
    // Atualizar informaÃ§Ãµes de paginaÃ§Ã£o
    updatePaginationInfo();
}

// FunÃ§Ã£o para atualizar informaÃ§Ãµes de paginaÃ§Ã£o
function updatePaginationInfo() {
    const start = (currentPage - 1) * itemsPerPage + 1;
    const end = Math.min(currentPage * itemsPerPage, filteredTransactions.length);
    const total = filteredTransactions.length;
    
    document.getElementById('transactions-start').textContent = start;
    document.getElementById('transactions-end').textContent = end;
    document.getElementById('transactions-total').textContent = total;
    
    const prevPageBtn = document.getElementById('prev-page-btn');
    const nextPageBtn = document.getElementById('next-page-btn');
    
    prevPageBtn.disabled = currentPage === 1;
    nextPageBtn.disabled = end >= total && !hasMoreTransactions;
}

// FunÃ§Ã£o para limpar cache automaticamente
function clearTransactionCache() {
    console.log('ðŸ§¹ Limpando cache de transaÃ§Ãµes...');
    allLoadedTransactions = [];
    filteredTransactions = [];
    lastLoadedDoc = null;
    currentPage = 1;
    hasMoreTransactions = true;
    isLoadingMore = false;
    
    // Limpar timer se existir
    if (cacheCleanupTimer) {
        clearTimeout(cacheCleanupTimer);
        cacheCleanupTimer = null;
    }
}

// FunÃ§Ã£o para agendar limpeza automÃ¡tica do cache
function scheduleCacheCleanup() {
    // Limpar cache apÃ³s 5 minutos de inatividade
    if (cacheCleanupTimer) {
        clearTimeout(cacheCleanupTimer);
    }
    
    cacheCleanupTimer = setTimeout(() => {
        console.log('â° Limpeza automÃ¡tica do cache executada');
        clearTransactionCache();
    }, 5 * 60 * 1000); // 5 minutos
}

// FunÃ§Ã£o para inicializar o sistema otimizado de transaÃ§Ãµes
async function initializeOptimizedTransactions() {
    try {
        // Limpar cache anterior
        clearTransactionCache();
        
        // Carregar primeira pÃ¡gina de transaÃ§Ãµes
        await loadMoreTransactionsInternal();
        
        // Agendar limpeza automÃ¡tica
        scheduleCacheCleanup();
        
        console.log('âœ… Sistema otimizado de transaÃ§Ãµes inicializado');
    } catch (error) {
        console.error('Erro ao inicializar transaÃ§Ãµes otimizadas:', error);
        showErrorModal('Erro ao carregar transaÃ§Ãµes. Tente novamente.');
    }
}

function changePage(delta) {
    const newPage = currentPage + delta;
    const maxPage = Math.ceil(filteredTransactions.length / itemsPerPage);
    
    if (newPage >= 1 && newPage <= maxPage) {
        currentPage = newPage;
        renderTransactionsOptimized();
    }
}

// FunÃ§Ã£o otimizada para carregar transaÃ§Ãµes com paginaÃ§Ã£o inteligente
async function loadMoreTransactionsInternal() {
    if (isLoadingMore || !hasMoreTransactions) return;
    
    try {
        isLoadingMore = true;
        
        // Mostrar indicador de carregamento
        const loadingElement = document.createElement('div');
        loadingElement.className = 'text-center py-4 text-gray-400';
        loadingElement.innerHTML = 'ðŸ”„ Carregando mais transaÃ§Ãµes...';
        transactionsList.appendChild(loadingElement);
        
        // Carregar transaÃ§Ãµes usando cursor-based pagination
        const result = await loadOlderTransactions(lastLoadedDoc, itemsPerPage);
        
        if (result.transactions.length > 0) {
            // Sistema otimizado: substituir cache em vez de acumular
            if (allLoadedTransactions.length === 0) {
                // Primeira carga: adicionar transaÃ§Ãµes
                allLoadedTransactions = [...result.transactions];
            } else {
                // Carregamentos subsequentes: substituir por novas transaÃ§Ãµes
                allLoadedTransactions = [...result.transactions];
            }
            
            // Agendar limpeza automÃ¡tica apÃ³s cada carregamento
            scheduleCacheCleanup();
            
            // Atualizar cursor para prÃ³xima pÃ¡gina
            lastLoadedDoc = result.lastDoc;
            hasMoreTransactions = result.hasMore;
            
            // Aplicar filtros atuais
            applyCurrentFilters();
            
            // Renderizar transaÃ§Ãµes
            renderTransactionsOptimized();
            
            console.log(`ðŸ“„ Carregadas ${result.transactions.length} transaÃ§Ãµes. Total em cache: ${allLoadedTransactions.length}`);
        } else {
            hasMoreTransactions = false;
            console.log('ðŸ“„ NÃ£o hÃ¡ mais transaÃ§Ãµes para carregar');
        }
        
        // Remover indicador de carregamento
        const loadingElements = transactionsList.querySelectorAll('.text-center.py-4.text-gray-400');
        loadingElements.forEach(el => {
            if (el.parentNode) {
                el.parentNode.removeChild(el);
            }
        });
        
    } catch (error) {
        console.error('Erro ao carregar mais transaÃ§Ãµes:', error);
        showErrorModal('Erro ao carregar mais transaÃ§Ãµes. Tente novamente.');
    } finally {
        isLoadingMore = false;
    }
}

// FunÃ§Ã£o otimizada para filtrar transaÃ§Ãµes
// FunÃ§Ã£o para aplicar filtros atuais
function applyCurrentFilters() {
    const typeFilter = transactionFilterType.value;
    const accountFilter = transactionFilterAccount.value;
    const dateFilter = transactionFilterDate.value;
    
    filteredTransactions = allLoadedTransactions.filter(transaction => {
        return passesCurrentFilters(transaction);
    });
}

// FunÃ§Ã£o auxiliar para verificar se uma transaÃ§Ã£o passa nos filtros atuais
function passesCurrentFilters(transaction) {
    const typeFilter = transactionFilterType.value;
    const accountFilter = transactionFilterAccount.value;
    const dateFilter = transactionFilterDate.value;
    
    // Filtro por tipo
    if (typeFilter && transaction.type !== typeFilter) {
        return false;
    }
    
    // Filtro por conta
    if (accountFilter && transaction.accountId !== accountFilter) {
        return false;
    }
    
    // Filtro por data
    if (dateFilter) {
        const transactionDate = transaction.date?.toDate ? transaction.date.toDate() : new Date(transaction.date);
        const filterDate = new Date(dateFilter);
        
        if (transactionDate.toDateString() !== filterDate.toDateString()) {
            return false;
        }
    }
    
    return true;
}

// FunÃ§Ã£o otimizada para filtrar transaÃ§Ãµes (compatibilidade)
function filterTransactions() {
    console.log('ðŸŽ¯ Filtros aplicados:', { 
        typeFilter: transactionFilterType.value, 
        accountFilter: transactionFilterAccount.value, 
        dateFilter: transactionFilterDate.value 
    });
    
    // Usar cache local limitado
    filteredTransactions = allLoadedTransactions.filter(transaction => {
        return passesCurrentFilters(transaction);
    });
    
    currentPage = 1;
    renderTransactionsOptimized();
}

function filterBills() {
    const statusFilter = billStatusFilter.value;
    const categoryFilter = billCategoryFilter.value;
    
    filteredBills = fixedBills.filter(bill => {
        // Filtro por status
        if (statusFilter) {
            const status = bill.status || calculateBillStatus(bill);
            if (status !== statusFilter) {
                return false;
            }
        }
        
        // Filtro por categoria
        if (categoryFilter && bill.category !== categoryFilter) {
            return false;
        }
        
        return true;
    });
    
    renderBillsView();
}

function updateTransactionFilters() {
    const accountSelect = transactionFilterAccount;
    accountSelect.innerHTML = '<option value="">Todas as contas</option>';
    
    accounts.forEach(account => {
        const option = document.createElement('option');
        option.value = account.id;
        option.textContent = account.name;
        accountSelect.appendChild(option);
    });
}

// FunÃ§Ãµes de pagamento de contas fixas
function handleFullPaymentModal(bill) {
    currentBillForPayment = bill;
    
    // Obter informaÃ§Ãµes completas da conta fixa para permitir pagamento antecipado
    getFixedBillInfoOptimized(bill.id).then(billInfo => {
        // Verificar se hÃ¡ perÃ­odos disponÃ­veis para pagamento
        const availablePeriods = billInfo.nextPeriodsToPay;
        
        if (availablePeriods.length === 0) {
            showWarningModal('NÃ£o hÃ¡ perÃ­odos disponÃ­veis para pagamento');
            return;
        }
        
        // CORREÃ‡ÃƒO: Identificar o perÃ­odo atual (primeiro perÃ­odo com valor restante)
        let currentPeriod = availablePeriods.find(period => period.isCurrentMonth && period.remainingAmount > 0);
        
        // Se nÃ£o hÃ¡ perÃ­odo atual com valor restante, verificar se hÃ¡ pagamento parcial em perÃ­odo futuro
        if (!currentPeriod) {
            // Buscar prÃ³ximo perÃ­odo com pagamento parcial (que deve ser tratado como perÃ­odo atual)
            currentPeriod = availablePeriods.find(period => 
                period.remainingAmount > 0 && 
                period.remainingAmount < bill.amount && 
                period.totalPaid > 0
            );
        }
        
        if (currentPeriod) {
            // PAGAMENTO NORMAL: HÃ¡ perÃ­odo atual com valor restante - pagar diretamente
            const remainingAmount = currentPeriod.remainingAmount;
            
            // Preencher informaÃ§Ãµes no modal
            document.getElementById('full-payment-bill-name').textContent = bill.description || bill.name;
            document.getElementById('full-payment-total-amount').textContent = `R$ ${bill.amount.toFixed(2)}`;
            document.getElementById('full-payment-paid-amount').textContent = `R$ ${currentPeriod.totalPaid.toFixed(2)}`;
            document.getElementById('full-payment-amount-to-pay').textContent = `R$ ${remainingAmount.toFixed(2)}`;
            
            // Preencher select de contas (apenas contas com saldo suficiente)
            fullPaymentAccount.innerHTML = '';
            const accountsWithBalance = accounts.filter(account => account.balance >= remainingAmount);
            
            if (accountsWithBalance.length === 0) {
                showWarningModal('Nenhuma conta possui saldo suficiente para este pagamento');
                return;
            }
            
            accountsWithBalance.forEach(account => {
                const option = document.createElement('option');
                option.value = account.id;
                option.textContent = `${account.name} (R$ ${account.balance.toFixed(2)})`;
                fullPaymentAccount.appendChild(option);
            });
            
            showModal(fullPaymentModal);
        } else {
            // PAGAMENTO ANTECIPADO: NÃ£o hÃ¡ perÃ­odo atual com valor restante - mostrar modal de seleÃ§Ã£o
            // Filtrar apenas perÃ­odos futuros (nÃ£o o atual)
            const futurePeriods = availablePeriods.filter(period => !period.isCurrentMonth && period.remainingAmount > 0);
            
            if (futurePeriods.length === 0) {
                showInfoModal('NÃ£o hÃ¡ perÃ­odos futuros disponÃ­veis para pagamento antecipado');
                return;
            }
            
            showPeriodSelectionModal(bill, futurePeriods);
        }
        
    }).catch(error => {
        showErrorModal(`Erro ao carregar dados da conta: ${error.message}`);
    });
}

// FunÃ§Ã£o para mostrar modal de seleÃ§Ã£o de perÃ­odos
function showPeriodSelectionModal(bill, availablePeriods) {
    // Criar modal dinamicamente
    const modalHtml = `
        <div id="period-selection-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-gray-800 rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto">
                <div class="p-6">
                    <div class="flex justify-between items-center mb-6">
                        <h3 class="text-xl font-semibold text-white">Pagamento Antecipado</h3>
                        <button id="close-period-selection-modal" class="text-gray-400 hover:text-white text-2xl">Ã—</button>
                    </div>
                    
                    <div class="mb-4">
                        <h4 class="text-lg font-medium text-white mb-2">${bill.description || bill.name}</h4>
                        <div class="text-sm text-gray-400">Valor: R$ ${bill.amount.toFixed(2)} â€¢ Vencimento: dia ${bill.dueDay}</div>
                    </div>
                    
                    <div class="space-y-3 mb-6">
                        <h5 class="text-md font-semibold text-white">Selecione o perÃ­odo para pagamento antecipado:</h5>
                        ${availablePeriods.map((period, index) => `
                            <div class="period-option p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600 transition duration-200" data-period="${period.period}" data-index="${index}">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <div class="text-white font-medium">${period.monthName} ${period.year}</div>
                                        <div class="text-sm text-gray-400">PerÃ­odo: ${period.period}</div>
                                    </div>
                                    <div class="text-right">
                                        <div class="text-sm text-gray-400">Pago: R$ ${period.totalPaid.toFixed(2)}</div>
                                        <div class="text-sm ${period.remainingAmount > 0 ? 'text-red-400' : 'text-green-400'}">
                                            Restante: R$ ${period.remainingAmount.toFixed(2)}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="flex space-x-3">
                        <button id="confirm-period-payment-btn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md transition duration-200 flex-1" disabled>
                            Pagar PerÃ­odo Selecionado
                        </button>
                        <button id="cancel-period-selection-btn" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md transition duration-200 flex-1">
                            Cancelar
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Adicionar modal ao DOM
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    const modal = document.getElementById('period-selection-modal');
    const closeBtn = document.getElementById('close-period-selection-modal');
    const cancelBtn = document.getElementById('cancel-period-selection-btn');
    const confirmBtn = document.getElementById('confirm-period-payment-btn');
    const periodOptions = modal.querySelectorAll('.period-option');
    
    let selectedPeriod = null;
    
    // Event listeners
    closeBtn.addEventListener('click', () => {
        modal.remove();
    });
    
    cancelBtn.addEventListener('click', () => {
        modal.remove();
    });
    
    // SeleÃ§Ã£o de perÃ­odo
    periodOptions.forEach(option => {
        option.addEventListener('click', () => {
            // Remover seleÃ§Ã£o anterior
            periodOptions.forEach(opt => opt.classList.remove('ring-2', 'ring-blue-500'));
            
            // Selecionar novo perÃ­odo
            option.classList.add('ring-2', 'ring-blue-500');
            selectedPeriod = availablePeriods[parseInt(option.dataset.index)];
            confirmBtn.disabled = false;
        });
    });
    
    // Confirmar pagamento
    confirmBtn.addEventListener('click', () => {
        if (selectedPeriod) {
            modal.remove();
            handlePeriodPayment(bill, selectedPeriod);
        }
    });
    
    // Fechar ao clicar fora
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.remove();
        }
    });
}

// FunÃ§Ã£o para processar pagamento de perÃ­odo especÃ­fico
async function handlePeriodPayment(bill, period) {
    try {
        // Mostrar modal de confirmaÃ§Ã£o bonito
        const confirmMessage = `Confirmar pagamento de R$ ${bill.amount.toFixed(2)} para o perÃ­odo ${period.monthName} ${period.year}?`;
        
        const confirmed = await showConfirmationModal(
            'Confirmar Pagamento Antecipado', 
            confirmMessage, 
            'ðŸ’³'
        );
        
        if (confirmed) {
            // Mostrar modal de seleÃ§Ã£o de conta
            showAccountSelectionModal(bill, period);
        }
    } catch (error) {
        await showErrorModal(`Erro ao realizar pagamento: ${error.message}`);
    }
}

// FunÃ§Ã£o para mostrar modal de seleÃ§Ã£o de conta
function showAccountSelectionModal(bill, period) {
    // Filtrar apenas contas com saldo suficiente
    const accountsWithBalance = accounts.filter(account => account.balance >= bill.amount);
    
    if (accountsWithBalance.length === 0) {
        showWarningModal(`Nenhuma conta possui saldo suficiente para pagar R$ ${bill.amount.toFixed(2)}`);
        return;
    }
    
    // Criar modal dinamicamente
    const modalHtml = `
        <div id="account-selection-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-gray-800 rounded-lg shadow-xl max-w-md w-full mx-4">
                <div class="p-6">
                    <div class="flex justify-between items-center mb-6">
                        <h3 class="text-xl font-semibold text-white">Selecionar Banco para Pagamento</h3>
                        <button id="close-account-selection-modal" class="text-gray-400 hover:text-white text-2xl">Ã—</button>
                    </div>
                    
                    <div class="mb-4">
                        <h4 class="text-lg font-medium text-white mb-2">${bill.description || bill.name}</h4>
                        <div class="text-sm text-gray-400">
                            PerÃ­odo: ${period.monthName} ${period.year} â€¢ Valor: R$ ${bill.amount.toFixed(2)}
                        </div>
                    </div>
                    
                    <div class="mb-6">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Banco com saldo suficiente:</label>
                        <select id="period-payment-account" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="">Selecione um banco</option>
                            ${accountsWithBalance.map(account => `
                                <option value="${account.id}">
                                    ${account.name} - R$ ${account.balance.toFixed(2)}
                                </option>
                            `).join('')}
                        </select>
                    </div>
                    
                    <div class="flex space-x-3">
                        <button id="confirm-period-payment-final-btn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md transition duration-200 flex-1" disabled>
                            Confirmar Pagamento
                        </button>
                        <button id="cancel-period-payment-btn" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md transition duration-200 flex-1">
                            Cancelar
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Adicionar modal ao DOM
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    const modal = document.getElementById('account-selection-modal');
    const closeBtn = document.getElementById('close-account-selection-modal');
    const cancelBtn = document.getElementById('cancel-period-payment-btn');
    const confirmBtn = document.getElementById('confirm-period-payment-final-btn');
    const accountSelect = document.getElementById('period-payment-account');
    
    // Event listeners
    closeBtn.addEventListener('click', () => {
        modal.remove();
    });
    
    cancelBtn.addEventListener('click', () => {
        modal.remove();
    });
    
    // Habilitar botÃ£o quando conta for selecionada
    accountSelect.addEventListener('change', () => {
        confirmBtn.disabled = !accountSelect.value;
    });
    
    // Confirmar pagamento
    confirmBtn.addEventListener('click', async () => {
        const selectedAccountId = accountSelect.value;
        if (!selectedAccountId) {
            showWarningModal('Por favor, selecione uma conta');
            return;
        }
        
        const selectedAccount = accounts.find(a => a.id === selectedAccountId);
        if (!selectedAccount) {
            showWarningModal('Conta selecionada nÃ£o encontrada');
            return;
        }
        
        if (selectedAccount.balance < bill.amount) {
            showWarningModal(`Saldo insuficiente na conta ${selectedAccount.name}. Saldo: R$ ${selectedAccount.balance.toFixed(2)}`);
            return;
        }
        
        modal.remove();
        
        try {
            // Realizar pagamento
            const result = await payFixedBill(
                bill.id,
                bill.amount,
                selectedAccountId,
                true, // pagamento completo
                period.period // perÃ­odo especÃ­fico
            );
            
            await showSuccessModal(`Pagamento de R$ ${bill.amount.toFixed(2)} realizado com sucesso para ${period.monthName} ${period.year}!`);
            
            // Atualizar visualizaÃ§Ã£o
            filterBills();
            
        } catch (error) {
            showErrorModal(`Erro ao realizar pagamento: ${error.message}`);
        }
    });
    
    // Fechar ao clicar fora
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.remove();
        }
    });
}

async function handleFullPayment() {
    if (!currentBillForPayment) {
        showWarningModal('Nenhuma conta selecionada para pagamento');
        return;
    }
    
    const selectedAccountId = fullPaymentAccount.value;
    if (!selectedAccountId) {
        showWarningModal('Por favor, selecione uma conta para pagamento');
        return;
    }
    
    const selectedAccount = accounts.find(a => a.id === selectedAccountId);
    if (!selectedAccount) {
        showWarningModal('Conta selecionada nÃ£o encontrada');
        return;
    }
    
    // Calcular valor restante usando a nova funÃ§Ã£o
    const billStatus = await getFixedBillStatus(currentBillForPayment.id);
    const remainingAmount = billStatus.remainingAmount;
    
    if (remainingAmount <= 0) {
        showWarningModal('Esta conta jÃ¡ foi paga completamente');
        return;
    }
    
    if (selectedAccount.balance < remainingAmount) {
        showWarningModal(`Saldo insuficiente na conta ${selectedAccount.name}. Saldo: R$ ${selectedAccount.balance.toFixed(2)}`);
        return;
    }
    
    try {
        // Usar a nova funÃ§Ã£o de pagamento
        const result = await payFixedBill(
            currentBillForPayment.id, 
            remainingAmount, 
            selectedAccountId, 
            true // Pagamento completo
        );
        
        await showSuccessModal(`Pagamento completo de R$ ${remainingAmount.toFixed(2)} realizado com sucesso!`);
        
        // Fechar modal e atualizar a visualizaÃ§Ã£o
        hideModal(fullPaymentModal);
        filterBills();
        
    } catch (error) {
        showErrorModal(`Erro ao realizar pagamento: ${error.message}`);
    }
}

function handlePartialPaymentModal(bill) {
    currentBillForPayment = bill;
    
    // Calcular valores usando a funÃ§Ã£o otimizada
    getFixedBillInfoOptimized(bill.id).then(billInfo => {
        // CORREÃ‡ÃƒO: Para pagamento parcial, permitir pagar prÃ³ximo perÃ­odo se atual jÃ¡ foi pago
        let targetPeriod = billInfo.periodsStatus.find(p => p.isCurrentMonth);
        
        // Se perÃ­odo atual jÃ¡ foi pago completamente, usar prÃ³ximo perÃ­odo disponÃ­vel
        if (!targetPeriod || targetPeriod.remainingAmount <= 0) {
            targetPeriod = billInfo.periodsStatus.find(p => p.canPay && p.remainingAmount > 0);
        }
        
        const billStatus = {
            remainingAmount: targetPeriod ? targetPeriod.remainingAmount : bill.amount,
            totalPaid: targetPeriod ? targetPeriod.totalPaid : 0
        };
        const remainingAmount = billStatus.remainingAmount;
        
        // Preencher informaÃ§Ãµes no modal
        document.getElementById('partial-payment-bill-name').textContent = bill.description || bill.name;
        document.getElementById('partial-payment-total-amount').textContent = `R$ ${bill.amount.toFixed(2)}`;
        document.getElementById('partial-payment-paid-amount').textContent = `R$ ${billStatus.totalPaid.toFixed(2)}`;
        document.getElementById('partial-payment-remaining-amount').textContent = `R$ ${remainingAmount.toFixed(2)}`;
        
        // Configurar input de pagamento
        partialPaymentAmount.value = '';
        partialPaymentAmount.max = remainingAmount;
        partialPaymentAmount.placeholder = `MÃ¡ximo: R$ ${remainingAmount.toFixed(2)}`;
        
        // Preencher select de contas
        partialPaymentAccount.innerHTML = '';
        accounts.forEach(account => {
            const option = document.createElement('option');
            option.value = account.id;
            option.textContent = `${account.name} (R$ ${account.balance.toFixed(2)})`;
            partialPaymentAccount.appendChild(option);
        });
        
        showModal(partialPaymentModal);
    }).catch(error => {
        showErrorModal(`Erro ao carregar dados da conta: ${error.message}`);
    });
}

async function handlePartialPayment() {
    if (!currentBillForPayment) {
        showWarningModal('Nenhuma conta selecionada para pagamento');
        return;
    }
    
    const paymentAmount = parseFloat(partialPaymentAmount.value);
    const accountId = partialPaymentAccount.value;
    
    if (!paymentAmount || paymentAmount <= 0) {
        showWarningModal('Por favor, informe um valor vÃ¡lido para o pagamento');
        return;
    }
    
    const selectedAccount = accounts.find(acc => acc.id === accountId);
    if (!selectedAccount) {
        showWarningModal('Conta nÃ£o encontrada');
        return;
    }
    
    if (selectedAccount.balance < paymentAmount) {
        showWarningModal(`Saldo insuficiente na conta ${selectedAccount.name}. Saldo: R$ ${selectedAccount.balance.toFixed(2)}`);
        return;
    }
    
    // Calcular valor restante usando a funÃ§Ã£o otimizada (mesma do modal)
    const billInfo = await getFixedBillInfoOptimized(currentBillForPayment.id);
    
    // CORREÃ‡ÃƒO: Para pagamento parcial, permitir pagar prÃ³ximo perÃ­odo se atual jÃ¡ foi pago
    let targetPeriod = billInfo.periodsStatus.find(p => p.isCurrentMonth);
    
    // Se perÃ­odo atual jÃ¡ foi pago completamente, usar prÃ³ximo perÃ­odo disponÃ­vel
    if (!targetPeriod || targetPeriod.remainingAmount <= 0) {
        targetPeriod = billInfo.periodsStatus.find(p => p.canPay && p.remainingAmount > 0);
    }
    
    const remainingAmount = targetPeriod ? targetPeriod.remainingAmount : currentBillForPayment.amount;
    
    if (paymentAmount > remainingAmount) {
        showWarningModal(`Valor do pagamento (R$ ${paymentAmount.toFixed(2)}) Ã© maior que o valor restante (R$ ${remainingAmount.toFixed(2)})`);
        return;
    }
    
    try {
        // Usar a nova funÃ§Ã£o de pagamento com perÃ­odo correto
        const result = await payFixedBill(
            currentBillForPayment.id, 
            paymentAmount, 
            accountId, 
            false, // Pagamento parcial
            targetPeriod ? targetPeriod.period : null // PerÃ­odo especÃ­fico se for antecipado
        );
        
        await showSuccessModal(`Pagamento parcial de R$ ${paymentAmount.toFixed(2)} realizado com sucesso!`);
        
        // Fechar modal e atualizar visualizaÃ§Ã£o
        hideModal(partialPaymentModal);
        filterBills();
        
    } catch (error) {
        showErrorModal(`Erro ao realizar pagamento: ${error.message}`);
    }
}

function updateFinancialSummary() {
    const total = accounts.reduce((sum, acc) => sum + acc.balance, 0);
    totalBalance.textContent = `R$ ${total.toFixed(2)}`;
    
    const currentMonth = new Date().getMonth();
    const currentYear = new Date().getFullYear();
    
    const monthTransactions = transactions.filter(t => {
        if (!t.date) return false;
        
        let transactionDate;
        try {
            if (t.date && typeof t.date.toDate === 'function') {
                transactionDate = t.date.toDate();
            } else if (t.date) {
                transactionDate = new Date(t.date);
            } else {
                return false;
            }
            
            if (isNaN(transactionDate.getTime())) {
                return false;
            }
            
            return transactionDate.getMonth() === currentMonth && 
                   transactionDate.getFullYear() === currentYear;
        } catch (error) {
            console.warn('Erro ao processar data da transaÃ§Ã£o:', error);
            return false;
        }
    });
    
    const income = monthTransactions
        .filter(t => t.type === 'income')
        .reduce((sum, t) => sum + t.amount, 0);
        
    const expenses = monthTransactions
        .filter(t => t.type === 'expense')
        .reduce((sum, t) => sum + t.amount, 0);
    
    monthlyIncome.textContent = `R$ ${income.toFixed(2)}`;
    monthlyExpenses.textContent = `R$ ${expenses.toFixed(2)}`;
    
    // Atualizar tambÃ©m o tÃ­tulo da pÃ¡gina com o saldo total
    document.title = `Dinah - R$ ${total.toFixed(2)}`;
}

// Handlers de formulÃ¡rios
async function handleAccountSubmit(e) {
    e.preventDefault();
    
    const name = accountName.value.trim();
    const balance = parseFloat(accountBalance.value);
    
    if (!name) {
        showWarningModal('Nome da conta Ã© obrigatÃ³rio');
        return;
    }
    
    if (isNaN(balance) || balance < 0) {
        showWarningModal('Saldo deve ser um nÃºmero vÃ¡lido maior ou igual a zero');
        return;
    }
    
    try {
        const accountIdValue = accountId.value;
        
        if (accountIdValue) {
            // Editar conta existente
            await updateAccount(accountIdValue, { name, balance });
        } else {
            // Adicionar nova conta
            await addAccount(name, balance);
        }
        
        resetAccountForm();
        hideModal(accountsModal);
    } catch (error) {
        showErrorModal(`Erro: ${error.message}`);
    }
}

async function handleBillSubmit(e) {
    e.preventDefault();
    
    const name = billName.value.trim();
    const amount = parseFloat(billAmount.value);
    const dueDay = parseInt(billDueDay.value);
    const category = billCategory.value;
    const startDate = document.getElementById('bill-start-date').value;
    
    if (!name) {
        showWarningModal('Nome da conta fixa Ã© obrigatÃ³rio');
        return;
    }
    
    if (isNaN(amount) || amount <= 0) {
        showWarningModal('Valor deve ser maior que zero');
        return;
    }
    
    if (isNaN(dueDay) || dueDay < 1 || dueDay > 31) {
        showWarningModal('Dia de vencimento deve estar entre 1 e 31');
        return;
    }
    
    if (!startDate) {
        showWarningModal('Data inicial Ã© obrigatÃ³ria');
        return;
    }
    
    try {
        const billIdValue = billId.value;
        
        if (billIdValue) {
            // Editar conta fixa existente
            await updateFixedBill(billIdValue, { name, amount, dueDay, category, startDate });
        } else {
            // Adicionar nova conta fixa
            await addFixedBill({ name, amount, dueDay, category, startDate });
        }
        
        resetBillForm();
        hideModal(billsModal);
    } catch (error) {
        showErrorModal(`Erro: ${error.message}`);
    }
}

// FunÃ§Ãµes de ediÃ§Ã£o
function editAccount(account) {
    accountId.value = account.id;
    accountName.value = account.name;
    accountBalance.value = account.balance;
    
    document.getElementById('account-form-title').textContent = 'Editar Conta';
    document.getElementById('save-account-btn').textContent = 'Atualizar';
}

function editBill(bill) {
    billId.value = bill.id;
    billName.value = bill.description || bill.name;
    billAmount.value = bill.amount;
    billDueDay.value = bill.dueDay;
    billCategory.value = bill.category || 'outros';
    
    // Definir data inicial se disponÃ­vel
    const startDateInput = document.getElementById('bill-start-date');
    if (bill.initialDate) {
        const initialDate = bill.initialDate.toDate ? bill.initialDate.toDate() : new Date(bill.initialDate);
        startDateInput.value = initialDate.toISOString().split('T')[0];
    } else {
        startDateInput.value = new Date().toISOString().split('T')[0];
    }
    
    document.getElementById('bill-form-title').textContent = 'Editar Conta Fixa';
    document.getElementById('save-bill-btn').textContent = 'Atualizar';
}

// FunÃ§Ãµes de reset
function resetAccountForm() {
    accountForm.reset();
    accountId.value = '';
    document.getElementById('account-form-title').textContent = 'Adicionar Nova Conta';
    document.getElementById('save-account-btn').textContent = 'Salvar';
}

function resetBillForm() {
    billForm.reset();
    billId.value = '';
    document.getElementById('bill-form-title').textContent = 'Adicionar Nova Conta Fixa';
    document.getElementById('save-bill-btn').textContent = 'Salvar';
    
    // Definir data atual como padrÃ£o
    document.getElementById('bill-start-date').value = new Date().toISOString().split('T')[0];
}

// FunÃ§Ãµes de confirmaÃ§Ã£o
let confirmCallback = null;

function showConfirmModal(title, message, callback) {
    document.getElementById('confirm-title').textContent = title;
    document.getElementById('confirm-message').textContent = message;
    confirmCallback = callback;
    showModal(confirmModal);
}

async function handleConfirmDelete() {
    if (confirmCallback) {
        try {
            await confirmCallback();
            hideModal(confirmModal);
        } catch (error) {
            showErrorModal(`Erro: ${error.message}`);
        }
    }
}

// FunÃ§Ãµes de modal
function showModal(modal) {
    modal.classList.remove('hidden');
}

function hideModal(modal) {
    modal.classList.add('hidden');
}

// FunÃ§Ãµes utilitÃ¡rias
function formatDate(date) {
    if (!date) return 'Data nÃ£o disponÃ­vel';
    
    try {
        let dateObj;
        
        // Se Ã© um timestamp do Firestore
        if (date && typeof date.toDate === 'function') {
            dateObj = date.toDate();
        }
        // Se Ã© uma string ou timestamp
        else if (typeof date === 'string' || typeof date === 'number') {
            dateObj = new Date(date);
        }
        // Se jÃ¡ Ã© um objeto Date
        else if (date instanceof Date) {
            dateObj = date;
        }
        // Se tem propriedades seconds/nanoseconds (Timestamp)
        else if (date && typeof date.seconds === 'number') {
            dateObj = new Date(date.seconds * 1000);
        }
        else {
            console.warn('Tipo de data nÃ£o reconhecido:', date);
            return 'Data invÃ¡lida';
        }
        
        // Verificar se a data Ã© vÃ¡lida
        if (isNaN(dateObj.getTime())) {
            console.warn('Data invÃ¡lida detectada:', date);
            return 'Data invÃ¡lida';
        }
        
        return dateObj.toLocaleDateString('pt-BR');
    } catch (error) {
        console.error('Erro ao formatar data:', error, date);
        return 'Data invÃ¡lida';
    }
}

function getTransactionTypeLabel(type) {
    const labels = {
        'income': 'Receita',
        'expense': 'Despesa',
        'transfer': 'TransferÃªncia',
        'transfer_in': 'TransferÃªncia Recebida',
        'transfer_out': 'TransferÃªncia Enviada'
    };
    return labels[type] || type;
}

// FunÃ§Ãµes para contas fixas
function calculateBillStatus(bill) {
    const today = new Date();
    const currentDay = today.getDate();
    const currentMonth = today.getMonth();
    const currentYear = today.getFullYear();
    
    // Calcular data de vencimento para o mÃªs atual
    const dueDate = new Date(currentYear, currentMonth, bill.dueDay);
    
    // Se o dia de vencimento jÃ¡ passou este mÃªs, calcular para o prÃ³ximo mÃªs
    if (currentDay > bill.dueDay) {
        dueDate.setMonth(currentMonth + 1);
    }
    
    // Calcular dias atÃ© o vencimento
    const daysUntilDue = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
    
    // Verificar se jÃ¡ foi paga (baseado em transaÃ§Ãµes)
    const billTransactions = transactions.filter(t => 
        t.billId === bill.id && 
        t.type === 'expense' &&
        (t.isPartialPayment || t.isBillPayment)
    );
    
    const totalPaid = billTransactions.reduce((sum, t) => sum + t.amount, 0);
    const remainingAmount = bill.amount - totalPaid;
    
    if (remainingAmount <= 0) {
        return 'paid';
    } else if (totalPaid > 0) {
        return 'partial';
    } else if (daysUntilDue < 0) {
        return 'overdue';
    } else if (daysUntilDue === 0) {
        return 'due-today';
    } else if (daysUntilDue <= 7) {
        return 'due-soon';
    } else {
        return 'pending';
    }
}

function getStatusClass(status) {
    const classes = {
        'paid': 'text-green-400',
        'partial': 'text-yellow-400',
        'pending': 'text-blue-400',
        'overdue': 'text-red-400',
        'due-soon': 'text-orange-400',
        'due-today': 'text-orange-500'
    };
    return classes[status] || 'text-gray-400';
}

function getStatusText(status) {
    const texts = {
        'paid': 'Paga',
        'partial': 'Paga Parcial',
        'pending': 'Pendente',
        'overdue': 'Vencida',
        'due-soon': 'Quase Vencendo',
        'due-today': 'Vence Hoje'
    };
    return texts[status] || 'Desconhecido';
}

// FunÃ§Ã£o para calcular data baseada na referÃªncia (hoje, ontem, anteontem)
function calculateDateFromReference(dateReference) {
    const today = new Date();
    
    switch (dateReference) {
        case 'ontem':
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            return yesterday;
        case 'anteontem':
            const dayBeforeYesterday = new Date(today);
            dayBeforeYesterday.setDate(today.getDate() - 2);
            return dayBeforeYesterday;
        case 'hoje':
        default:
            return today;
    }
}

// FunÃ§Ã£o para processar aÃ§Ãµes de botÃµes
async function handleButtonAction(action, accountName) {
    try {
        console.log('ðŸ”„ Processando aÃ§Ã£o do botÃ£o:', action, accountName);
        
        // Verificar se Ã© uma aÃ§Ã£o de dÃ©bito
        if (action.startsWith('debitar_')) {
            const accountNameFromAction = action.replace('debitar_', '');
            const account = accounts.find(acc => acc.name === accountNameFromAction);
            
            if (!account) {
                addChatMessage('assistant', `${getUserDisplayName()}, nÃ£o encontrei a conta "${accountNameFromAction}". Por favor, tente novamente.`);
                return;
            }
            
            // Buscar o valor e descriÃ§Ã£o da despesa pendente
            const lastAssistantMessage = [...chatMessages.children]
                .reverse()
                .find(msg => msg.classList.contains('assistant'))
                ?.textContent;
            
            if (lastAssistantMessage) {
                const valueMatch = lastAssistantMessage.match(/R\$\s*([\d,]+\.?\d*)/);
                const descMatch = lastAssistantMessage.match(/- ([^.]+)/);
                
                if (valueMatch) {
                    const amount = parseFloat(valueMatch[1].replace(',', '.'));
                    const description = descMatch ? descMatch[1].trim() : 'Gasto';
                    
                    // Verificar saldo
                    if (account.balance < amount) {
                        addChatMessage('assistant', `${getUserDisplayName()}, saldo insuficiente na conta ${account.name}. Saldo atual: R$ ${account.balance.toFixed(2)}`);
                        return;
                    }
                    
                    // Processar despesa
                    await addTransaction({
                        type: 'expense',
                        amount: amount,
                        description: description,
                        accountId: account.id,
                        category: 'outros',
                        date: new Date()
                    });
                    
                    addChatMessage('assistant', `${getUserDisplayName()}, despesa de R$ ${amount.toFixed(2)} registrada na conta ${account.name} - ${description}`);
                }
            }
        }
        // Verificar se Ã© uma aÃ§Ã£o de crÃ©dito
        else if (action.startsWith('creditar_')) {
            const accountNameFromAction = action.replace('creditar_', '');
            const account = accounts.find(acc => acc.name === accountNameFromAction);
            
            if (!account) {
                addChatMessage('assistant', `${getUserDisplayName()}, nÃ£o encontrei a conta "${accountNameFromAction}". Por favor, tente novamente.`);
                return;
            }
            
            // Buscar o valor e descriÃ§Ã£o da receita pendente
            const lastAssistantMessage = [...chatMessages.children]
                .reverse()
                .find(msg => msg.classList.contains('assistant'))
                ?.textContent;
            
            if (lastAssistantMessage) {
                const valueMatch = lastAssistantMessage.match(/R\$\s*([\d,]+\.?\d*)/);
                const descMatch = lastAssistantMessage.match(/- ([^.]+)/);
                
                if (valueMatch) {
                    const amount = parseFloat(valueMatch[1].replace(',', '.'));
                    const description = descMatch ? descMatch[1].trim() : 'Receita';
                    
                    // Processar receita
                    await addTransaction({
                        type: 'income',
                        amount: amount,
                        description: description,
                        accountId: account.id,
                        category: 'outros',
                        date: new Date()
                    });
                    
                    addChatMessage('assistant', `${getUserDisplayName()}, receita de R$ ${amount.toFixed(2)} registrada na conta ${account.name} - ${description}`);
                }
            }
        }
        else {
            // Para outras aÃ§Ãµes, processar como mensagem normal
            chatInput.value = accountName;
            handleSendMessage();
        }
    } catch (error) {
        console.error('Erro ao processar aÃ§Ã£o do botÃ£o:', error);
        addChatMessage('assistant', `${getUserDisplayName()}, ocorreu um erro ao processar sua solicitaÃ§Ã£o. Tente novamente.`);
    }
}

function addChatMessage(sender, message, buttons = null) {
    const messageElement = document.createElement('div');
    messageElement.className = `chat-message ${sender}`;
    
    // Criar container para a mensagem
    const messageContainer = document.createElement('div');
    messageContainer.innerHTML = message.replace(/\n/g, '<br>');
    messageElement.appendChild(messageContainer);
    
    // Adicionar botÃµes se existirem
    if (buttons && Array.isArray(buttons)) {
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'chat-buttons';
        buttonsContainer.style.marginTop = '10px';
        buttonsContainer.style.display = 'flex';
        buttonsContainer.style.gap = '8px';
        buttonsContainer.style.flexWrap = 'wrap';
        
        buttons.forEach(button => {
            const buttonElement = document.createElement('button');
            buttonElement.textContent = button.text;
            buttonElement.className = `chat-button ${button.style || 'primary'}`;
            buttonElement.disabled = button.disabled || false;
            
            // Estilos dos botÃµes
            buttonElement.style.padding = '6px 12px';
            buttonElement.style.border = 'none';
            buttonElement.style.borderRadius = '4px';
            buttonElement.style.cursor = button.disabled ? 'not-allowed' : 'pointer';
            buttonElement.style.fontSize = '12px';
            buttonElement.style.fontWeight = '500';
            buttonElement.style.transition = 'all 0.2s ease';
            buttonElement.style.minWidth = '120px';
            buttonElement.style.maxWidth = '150px';
            buttonElement.style.flex = '1';
            
            // Cores baseadas no estilo
            if (button.style === 'success') {
                buttonElement.style.backgroundColor = '#10b981';
                buttonElement.style.color = 'white';
            } else if (button.style === 'danger') {
                buttonElement.style.backgroundColor = '#ef4444';
                buttonElement.style.color = 'white';
            } else if (button.style === 'primary') {
                buttonElement.style.backgroundColor = '#3b82f6';
                buttonElement.style.color = 'white';
            } else {
                buttonElement.style.backgroundColor = '#6b7280';
                buttonElement.style.color = 'white';
            }
            
            // Efeito hover
            if (!button.disabled) {
                buttonElement.addEventListener('mouseenter', () => {
                    buttonElement.style.opacity = '0.8';
                    buttonElement.style.transform = 'translateY(-1px)';
                });
                buttonElement.addEventListener('mouseleave', () => {
                    buttonElement.style.opacity = '1';
                    buttonElement.style.transform = 'translateY(0)';
                });
            }
            
            // Evento de clique
            buttonElement.addEventListener('click', () => {
                if (!button.disabled) {
                    // Ocultar todos os botÃµes da mensagem
                    const allButtons = buttonsContainer.querySelectorAll('button');
                    allButtons.forEach(btn => {
                        btn.style.opacity = '0.5';
                        btn.style.pointerEvents = 'none';
                        btn.style.transform = 'scale(0.95)';
                    });
                    
                    // Processar aÃ§Ã£o especÃ­fica ou enviar como mensagem
                    if (button.action) {
                        // Processar aÃ§Ã£o especÃ­fica
                        setTimeout(() => {
                            handleButtonAction(button.action, button.text);
                        }, 200);
                    } else {
                        // Enviar o valor do botÃ£o como mensagem apÃ³s um pequeno delay
                        setTimeout(() => {
                            chatInput.value = button.value || button.text;
                            handleSendMessage();
                        }, 200);
                    }
                }
            });
            
            buttonsContainer.appendChild(buttonElement);
        });
        
        messageElement.appendChild(buttonsContainer);
    }
    
    chatMessages.appendChild(messageElement);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

// FunÃ§Ã£o auxiliar para obter nome da categoria
function getCategoryName(category) {
    const categoryNames = {
        'moradia': 'Moradia',
        'energia': 'Energia',
        'agua': 'Ãgua',
        'internet': 'Internet',
        'telefone': 'Telefone',
        'gas': 'GÃ¡s',
        'condominio': 'CondomÃ­nio',
        'seguro': 'Seguro',
        'escola': 'EducaÃ§Ã£o',
        'cartao': 'CartÃ£o de CrÃ©dito',
        'streaming': 'Streaming',
        'academia': 'Academia',
        'outros': 'Outros'
    };
    return categoryNames[category] || 'Outros';
}

// FunÃ§Ã£o de debug para investigar auto-expansÃ£o
async function debugAutoExpansion(billId) {
    try {
        console.log('ðŸ” === DEBUG AUTO-EXPANSÃƒO ===');
        
        // Buscar dados da conta fixa
        const billRef = doc(db, 'users', auth.currentUser.uid, 'recurring_bills', billId);
        const billDoc = await getDoc(billRef);
        const billData = billDoc.data();
        
        console.log('ðŸ“Š Dados da conta fixa:', {
            description: billData.description,
            autoExpansionEnabled: billData.autoExpansionEnabled,
            totalPeriodsGenerated: billData.totalPeriodsGenerated,
            initialDate: billData.initialDate?.toDate ? billData.initialDate.toDate() : new Date(billData.initialDate),
            dueDay: billData.dueDay
        });
        
        const initialDate = billData.initialDate?.toDate ? billData.initialDate.toDate() : new Date(billData.initialDate);
        const totalPeriods = billData.totalPeriodsGenerated || 12;
        const periods = calculateAllPeriodsFromInitial(initialDate, billData.dueDay, totalPeriods, false);
        
        console.log('ðŸ“‹ PerÃ­odos calculados:', periods.map(p => ({
            period: p.period,
            monthName: p.monthName,
            year: p.year
        })));
        
        // Verificar pagamentos de cada perÃ­odo
        const paidPeriods = [];
        const unpaidPeriods = [];
        
        for (let i = 0; i < periods.length; i++) {
            const period = periods[i];
            const periodStatus = await getMonthPaymentStatus(billId, period.year, period.month);
            
            if (periodStatus.isFullyPaid) {
                paidPeriods.push({
                    index: i,
                    period: period.period,
                    monthName: period.monthName,
                    year: period.year
                });
            } else {
                unpaidPeriods.push({
                    index: i,
                    period: period.period,
                    monthName: period.monthName,
                    year: period.year,
                    remainingAmount: periodStatus.remainingAmount
                });
            }
        }
        
        console.log('âœ… PerÃ­odos pagos:', paidPeriods);
        console.log('â³ PerÃ­odos nÃ£o pagos:', unpaidPeriods);
        
        // Calcular perÃ­odos restantes
        const lastPaidIndex = paidPeriods.length > 0 ? Math.max(...paidPeriods.map(p => p.index)) : -1;
        const periodsRemaining = periods.length - (lastPaidIndex + 1);
        
        console.log('ðŸ“Š AnÃ¡lise:', {
            totalPeriods: periods.length,
            paidPeriods: paidPeriods.length,
            unpaidPeriods: unpaidPeriods.length,
            lastPaidIndex: lastPaidIndex,
            periodsRemaining: periodsRemaining,
            shouldExpand: periodsRemaining <= 5
        });
        
        return {
            billData,
            periods,
            paidPeriods,
            unpaidPeriods,
            periodsRemaining,
            shouldExpand: periodsRemaining <= 5
        };
        
    } catch (error) {
        console.error('âŒ Erro no debug:', error);
        throw error;
    }
}

async function checkAndExpandAllBills() {
    if (!fixedBills || fixedBills.length === 0) return;
    
    try {
        let expandedCount = 0;
        const expansionResults = [];
        
        // Verificar cada conta fixa individualmente
        for (const bill of fixedBills) {
            try {
                const result = await checkAndExpandPeriods(bill.id);
                if (result.expanded) {
                    expandedCount++;
                    expansionResults.push({
                        billId: bill.id,
                        billName: bill.description,
                        expanded: true,
                        message: result.message,
                        newTotalPeriods: result.newTotalPeriods
                    });
                }
            } catch (error) {
                console.warn(`Erro ao verificar expansÃ£o da conta ${bill.description}:`, error);
            }
        }
        
        // Se houve expansÃµes, mostrar notificaÃ§Ã£o
        if (expandedCount > 0) {
            const message = expandedCount === 1 
                ? `âœ… ${expansionResults[0].billName}: ${expansionResults[0].message}`
                : `âœ… ${expandedCount} contas fixas foram expandidas automaticamente!`;
            
            await showSuccessModal(message);
            
            // Atualizar a visualizaÃ§Ã£o
            renderFixedBills();
            renderBillsView();
        }
        
        return expansionResults;
        
    } catch (error) {
        console.error('Erro ao verificar expansÃ£o de contas fixas:', error);
        throw error;
    }
}

// FunÃ§Ã£o para mostrar histÃ³rico de pagamentos
async function showPaymentHistory(billId) {
    try {
        // Usar funÃ§Ã£o otimizada para obter histÃ³rico
        const paymentHistory = await getFixedBillPaymentHistoryOptimized(billId, 12);
        
        // Buscar dados bÃ¡sicos da conta fixa
        const billRef = doc(db, 'users', auth.currentUser.uid, 'recurring_bills', billId);
        const billDoc = await getDoc(billRef);
        
        if (!billDoc.exists()) {
            throw new Error('Conta fixa nÃ£o encontrada');
        }
        
        const billData = billDoc.data();
        
        // Preencher conteÃºdo do modal
        const content = document.getElementById('payment-history-content');
        // Renderizar histÃ³rico otimizado
        const historyHtml = paymentHistory.map(period => `
            <div class="bg-gray-700 rounded-lg p-4 mb-3">
                <div class="flex justify-between items-center mb-2">
                    <h5 class="font-medium text-white">${period.monthName} ${period.period.split('-')[0]}</h5>
                    <span class="text-sm ${period.totalPaid >= billData.amount ? 'text-green-400' : 'text-yellow-400'}">
                        ${period.totalPaid >= billData.amount ? 'âœ… Pago' : 'âš ï¸ Parcial'}
                    </span>
                </div>
                <div class="grid grid-cols-2 gap-4 text-sm">
                    <div>
                        <span class="text-gray-400">Valor:</span>
                        <span class="text-white">R$ ${billData.amount.toFixed(2)}</span>
                    </div>
                    <div>
                        <span class="text-gray-400">Pago:</span>
                        <span class="text-green-400">R$ ${period.totalPaid.toFixed(2)}</span>
                    </div>
                    <div>
                        <span class="text-gray-400">Restante:</span>
                        <span class="text-red-400">R$ ${(billData.amount - period.totalPaid).toFixed(2)}</span>
                    </div>
                    <div>
                        <span class="text-gray-400">Pagamentos:</span>
                        <span class="text-blue-400">${period.paymentCount}</span>
                    </div>
                </div>
                ${period.payments.length > 0 ? `
                    <div class="mt-3 pt-3 border-t border-gray-600">
                        <div class="text-xs text-gray-400 mb-2">Detalhes dos pagamentos:</div>
                        ${period.payments.map(payment => `
                            <div class="text-xs text-gray-300 mb-1">
                                â€¢ R$ ${payment.amount.toFixed(2)} - ${new Date(payment.date?.toDate ? payment.date.toDate() : payment.date).toLocaleDateString('pt-BR')}
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
            </div>
        `).join('');
        
        content.innerHTML = `
            <div class="mb-6">
                <h4 class="text-lg font-semibold text-white mb-2">${billData.description}</h4>
                <div class="text-sm text-gray-400">
                    Valor: R$ ${billData.amount.toFixed(2)} â€¢ Vencimento: dia ${billData.dueDay}
                </div>
            </div>
            
            <div class="space-y-3">
                <h5 class="text-md font-semibold text-white mb-3">ðŸ“Š HistÃ³rico de Pagamentos</h5>
                ${historyHtml || '<div class="text-center py-8 text-gray-400">Nenhum pagamento encontrado</div>'}
            </div>
        `;
        
        // Mostrar modal
        const paymentHistoryModal = document.getElementById('payment-history-modal');
        paymentHistoryModal.classList.remove('hidden');
        paymentHistoryModal.dataset.currentBillId = billId;
        
    } catch (error) {
        console.error('Erro ao carregar histÃ³rico:', error);
        showErrorModal('Erro ao carregar histÃ³rico de pagamentos');
    }
}

// Controle de telas
function showLoginScreen() {
    loginScreen.classList.remove('hidden');
    appScreen.classList.add('hidden');
}

function showAppScreen() {
    loginScreen.classList.add('hidden');
    appScreen.classList.remove('hidden');
}

// UtilitÃ¡rios
function showAuthError(message) {
    authError.textContent = message;
    authError.classList.remove('hidden');
}

function hideAuthError() {
    authError.classList.add('hidden');
}

// FunÃ§Ã£o para atualizar interface apÃ³s estorno de transaÃ§Ã£o
async function updateInterfaceAfterRefund(transactionId) {
    try {
        console.log('ðŸ”„ Atualizando interface apÃ³s estorno...');
        
        // Remover transaÃ§Ã£o do cache local
        allLoadedTransactions = allLoadedTransactions.filter(t => t.id !== transactionId);
        filteredTransactions = filteredTransactions.filter(t => t.id !== transactionId);
        
        // Remover das transaÃ§Ãµes recentes tambÃ©m
        transactions = transactions.filter(t => t.id !== transactionId);
        
        // Atualizar interface das transaÃ§Ãµes recentes
        renderRecentTransactions();
        
        // Se o modal de transaÃ§Ãµes estiver aberto, atualizar tambÃ©m
        if (!transactionsModal.classList.contains('hidden')) {
            renderTransactionsOptimized();
        }
        
        // Se o modal de histÃ³rico de pagamentos estiver aberto, atualizar tambÃ©m
        const paymentHistoryModal = document.getElementById('payment-history-modal');
        if (paymentHistoryModal && !paymentHistoryModal.classList.contains('hidden')) {
            // Recarregar histÃ³rico se estiver aberto
            const currentBillId = paymentHistoryModal.dataset.currentBillId;
            if (currentBillId) {
                await showPaymentHistory(currentBillId);
            }
        }
        
        // Atualizar resumo financeiro
        updateFinancialSummary();
        
        console.log('âœ… Interface atualizada apÃ³s estorno');
        
    } catch (error) {
        console.error('Erro ao atualizar interface apÃ³s estorno:', error);
    }
}

// FunÃ§Ã£o para estornar transaÃ§Ã£o (deve ser global para o onclick)
window.handleRefund = async function(transactionId) {
    try {
        // Verificar se a transaÃ§Ã£o ainda existe no cache local
        const transactionExists = allLoadedTransactions.some(t => t.id === transactionId) || 
                                 transactions.some(t => t.id === transactionId);
        
        if (!transactionExists) {
            showWarningModal('Esta transaÃ§Ã£o jÃ¡ foi estornada ou nÃ£o existe mais.');
            return;
        }
        
        // Mostrar modal de confirmaÃ§Ã£o
        showConfirmModal(
            'Confirmar Estorno',
            'Tem certeza que deseja estornar esta transaÃ§Ã£o? Esta aÃ§Ã£o irÃ¡ reverter o saldo da conta e remover a transaÃ§Ã£o do histÃ³rico.',
            async () => {
                try {
                    const refundResult = await refundTransaction(transactionId);
                    showSuccessModal(refundResult.message);
                    
                    // Atualizar interface imediatamente apÃ³s estorno
                    await updateInterfaceAfterRefund(transactionId);
                    
                } catch (error) {
                    showErrorModal(`Erro ao estornar transaÃ§Ã£o: ${error.message}`);
                }
            }
        );
    } catch (error) {
        showErrorModal(`Erro ao processar estorno: ${error.message}`);
    }
};

// FunÃ§Ã£o global para carregar mais transaÃ§Ãµes
window.loadMoreTransactions = async function() {
    await loadMoreTransactionsInternal();
};

// FunÃ§Ã£o de debug para investigar auto-expansÃ£o
window.debugAutoExpansion = debugAutoExpansion;

// FunÃ§Ã£o para estornar transaÃ§Ã£o (versÃ£o interna)
async function handleRefundInternal(transactionId) {
    try {
        const result = await showConfirmModal(
            'Confirmar Estorno',
            'Tem certeza que deseja estornar esta transaÃ§Ã£o? Esta aÃ§Ã£o irÃ¡ reverter o saldo da conta e remover a transaÃ§Ã£o do histÃ³rico.',
            async () => {
                const refundResult = await refundTransaction(transactionId);
                showSuccessModal(refundResult.message);
                
                // Atualizar interface imediatamente apÃ³s estorno
                await updateInterfaceAfterRefund(transactionId);
            }
        );
    } catch (error) {
        showErrorModal(`Erro ao estornar transaÃ§Ã£o: ${error.message}`);
    }
}

// Teste para verificar se tudo estÃ¡ funcionando
console.log('ðŸ”§ Testando sistema de estorno...');

// Verificar se a funÃ§Ã£o estÃ¡ disponÃ­vel globalmente
if (typeof window.handleRefund === 'function') {
} else {
    console.log('âŒ FunÃ§Ã£o handleRefund NÃƒO estÃ¡ disponÃ­vel globalmente');
}

// Verificar se a funÃ§Ã£o refundTransaction estÃ¡ sendo importada
if (typeof refundTransaction === 'function') {
} else {
    console.log('âŒ FunÃ§Ã£o refundTransaction NÃƒO estÃ¡ disponÃ­vel');
}

// Verificar se a funÃ§Ã£o showConfirmModal estÃ¡ disponÃ­vel
if (typeof showConfirmModal === 'function') {
} else {
    console.log('âŒ FunÃ§Ã£o showConfirmModal NÃƒO estÃ¡ disponÃ­vel');
}

console.log('ðŸŽ‰ Sistema de estorno testado com sucesso!');

import { 
    onAuthStateChangedListener, 
    signInUser, 
    signUpUser, 
    signOutUser,
    onAccountsUpdate,
    onTransactionsUpdate,
    onFixedBillsUpdate,
    addTransaction,
    performTransfer,
    addAccount,
    addFixedBill,
    updateAccount,
    updateFixedBill,
    deleteAccount,
    deleteFixedBill,
    deleteAllTransactions,
    addDebt,
    queryDebts,
    refundTransaction,
    payFixedBill,
    getFixedBillStatus,
    getFixedBillsWithStatus,
    markFixedBillAsPaid,
    loadOlderTransactions,
    loadTransactionsWithPagination,
    getFixedBillInfo,
    getFixedBillInfoOptimized,
    checkAndExpandPeriods,
    getMonthPaymentStatus,
    getFixedBillPaymentHistoryOptimized,
    getMultipleMonthsStatusOptimized,
    analyzeMonthlyComparison,
    generateSavingsSuggestions
} from './src/firestoreService.js';
import { db, auth } from './firebase-config.js';
import { 
    collection, 
    query, 
    where, 
    getDocs,
    doc,
    getDoc
} from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
import { processMessageAdvanced, AdvancedContextManager } from './src/nlu-advanced.js';

// ========================================
// üîß FUN√á√ïES AUXILIARES PARA CONTAS FIXAS
// ========================================

// Fun√ß√£o para obter per√≠odo (YYYY-MM) de uma data
function getPeriodFromDate(date) {
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    return `${year}-${month}`;
}

// Fun√ß√£o para calcular todos os per√≠odos desde a data inicial
function calculateAllPeriodsFromInitial(initialDate, dueDay, monthsCount = 12, autoExpand = true) {
    const periods = [];
    const startYear = initialDate.getFullYear();
    const startMonth = initialDate.getMonth() + 1;
    
    const maxMonths = autoExpand ? monthsCount : monthsCount;
    
    for (let i = 0; i < maxMonths; i++) {
        const targetMonth = startMonth + i;
        const targetYear = targetMonth > 12 ? startYear + Math.floor((targetMonth - 1) / 12) : startYear;
        const adjustedMonth = targetMonth > 12 ? ((targetMonth - 1) % 12) + 1 : targetMonth;
        
        const period = `${targetYear}-${adjustedMonth.toString().padStart(2, '0')}`;
        periods.push({
            period,
            year: targetYear,
            month: adjustedMonth,
            monthName: new Date(targetYear, adjustedMonth - 1).toLocaleDateString('pt-BR', { month: 'long' }),
            dueDate: new Date(targetYear, adjustedMonth - 1, dueDay),
            isAutoGenerated: i >= 12
        });
    }
    
    return periods;
}

// ========================================
// üé® SISTEMA DE MODAIS BONITOS
// ========================================

// Fun√ß√£o para mostrar modal de notifica√ß√£o (substitui alert)
function showNotificationModal(title, message, icon = '‚ÑπÔ∏è') {
    return new Promise((resolve) => {
        const modal = document.getElementById('notification-modal');
        const titleEl = document.getElementById('notification-title');
        const messageEl = document.getElementById('notification-message');
        const iconEl = document.getElementById('notification-icon');
        const okBtn = document.getElementById('notification-ok-btn');
        
        titleEl.textContent = title;
        messageEl.textContent = message;
        iconEl.textContent = icon;
        
        // Remover listeners anteriores
        const newOkBtn = okBtn.cloneNode(true);
        okBtn.parentNode.replaceChild(newOkBtn, okBtn);
        
        newOkBtn.addEventListener('click', () => {
            hideModal(modal);
            resolve(true);
        });
        
        // Fechar ao clicar fora
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                hideModal(modal);
                resolve(true);
            }
        });
        
        showModal(modal);
    });
}

// Fun√ß√£o para mostrar modal de confirma√ß√£o (substitui confirm)
function showConfirmationModal(title, message, icon = '‚ùì') {
    return new Promise((resolve) => {
        const modal = document.getElementById('confirmation-modal');
        const titleEl = document.getElementById('confirmation-title');
        const messageEl = document.getElementById('confirmation-message');
        const iconEl = document.getElementById('confirmation-icon');
        const cancelBtn = document.getElementById('confirmation-cancel-btn');
        const confirmBtn = document.getElementById('confirmation-confirm-btn');
        
        titleEl.textContent = title;
        messageEl.textContent = message;
        iconEl.textContent = icon;
        
        // Remover listeners anteriores
        const newCancelBtn = cancelBtn.cloneNode(true);
        const newConfirmBtn = confirmBtn.cloneNode(true);
        cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        
        newCancelBtn.addEventListener('click', () => {
            hideModal(modal);
            resolve(false);
        });
        
        newConfirmBtn.addEventListener('click', () => {
            hideModal(modal);
            resolve(true);
        });
        
        // Fechar ao clicar fora
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                hideModal(modal);
                resolve(false);
            }
        });
        
        showModal(modal);
    });
}

// Fun√ß√£o para mostrar modal de sucesso
function showSuccessModal(message) {
    return new Promise((resolve) => {
        const modal = document.getElementById('success-modal');
        const messageEl = document.getElementById('success-message');
        const okBtn = document.getElementById('success-ok-btn');
        
        messageEl.textContent = message;
        
        // Remover listeners anteriores
        const newOkBtn = okBtn.cloneNode(true);
        okBtn.parentNode.replaceChild(newOkBtn, okBtn);
        
        newOkBtn.addEventListener('click', () => {
            hideModal(modal);
            resolve(true);
        });
        
        // Fechar ao clicar fora
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                hideModal(modal);
                resolve(true);
            }
        });
        
        showModal(modal);
    });
}

// Fun√ß√£o para mostrar modal de erro
function showErrorModal(message) {
    return new Promise((resolve) => {
        const modal = document.getElementById('error-modal');
        const messageEl = document.getElementById('error-message');
        const okBtn = document.getElementById('error-ok-btn');
        
        messageEl.textContent = message;
        
        // Remover listeners anteriores
        const newOkBtn = okBtn.cloneNode(true);
        okBtn.parentNode.replaceChild(newOkBtn, okBtn);
        
        newOkBtn.addEventListener('click', () => {
            hideModal(modal);
            resolve(true);
        });
        
        // Fechar ao clicar fora
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                hideModal(modal);
                resolve(true);
            }
        });
        
        showModal(modal);
    });
}

// Fun√ß√£o para mostrar modal de aviso
function showWarningModal(message) {
    return showNotificationModal('Aten√ß√£o', message, '‚ö†Ô∏è');
}

// Fun√ß√£o para mostrar modal de informa√ß√£o
function showInfoModal(message) {
    return showNotificationModal('Informa√ß√£o', message, '‚ÑπÔ∏è');
}

// ========================================
// üîÑ SUBSTITUI√á√ïES DOS ALERTS E CONFIRMS
// ========================================

// Substituir alert() por showNotificationModal()
function alert(message) {
    return showNotificationModal('Notifica√ß√£o', message, '‚ÑπÔ∏è');
}

// Substituir confirm() por showConfirmationModal()
function confirm(message) {
    return showConfirmationModal('Confirmar', message, '‚ùì');
}

// Estado da aplica√ß√£o
let currentUser = null;
let accounts = [];
let transactions = [];
let fixedBills = [];
let contextManager = new AdvancedContextManager();

// Estado de pagina√ß√£o otimizada para milh√µes de transa√ß√µes
let currentPage = 1;
let itemsPerPage = 20;
let filteredTransactions = [];
let allLoadedTransactions = []; // Cache local limitado
let isLoadingMore = false;
let hasMoreTransactions = true;
let lastLoadedDoc = null; // Para cursor-based pagination
let maxCacheSize = 20; // Reduzido para apenas 20 transa√ß√µes (uma p√°gina)
let cacheCleanupTimer = null; // Timer para limpeza autom√°tica

// Estado de contas fixas
let filteredBills = [];
let currentBillForPayment = null;

// Listeners do Firestore
let accountsUnsubscribe = null;
let transactionsUnsubscribe = null;
let fixedBillsUnsubscribe = null;

// Elementos da UI
const loginScreen = document.getElementById('login-screen');
const appScreen = document.getElementById('app-screen');
const loginForm = document.getElementById('login-form');
const emailInput = document.getElementById('email');
const passwordInput = document.getElementById('password');
const loginBtn = document.getElementById('login-btn');
const signupBtn = document.getElementById('signup-btn');
const authError = document.getElementById('auth-error');
const logoutBtn = document.getElementById('logout-btn');
const chatInput = document.getElementById('chat-input');
const sendBtn = document.getElementById('send-btn');
const chatMessages = document.getElementById('chat-messages');

// Elementos da sidebar
const totalBalance = document.getElementById('total-balance');
const monthlyIncome = document.getElementById('monthly-income');
const monthlyExpenses = document.getElementById('monthly-expenses');
const accountsList = document.getElementById('accounts-list');
const fixedBillsSection = document.getElementById('fixed-bills-section');
const recentTransactions = document.getElementById('recent-transactions');

// Bot√µes de gerenciamento
const manageAccountsBtn = document.getElementById('manage-accounts-btn');
const manageBillsBtn = document.getElementById('manage-bills-btn');
const addAccountBtn = document.getElementById('add-account-btn');
const addBillBtn = document.getElementById('add-bill-btn');
const viewAllBillsBtn = document.getElementById('view-all-bills-btn');
const viewAllTransactionsBtn = document.getElementById('view-all-transactions-btn');

// Modais
const accountsModal = document.getElementById('accounts-modal');
const billsModal = document.getElementById('bills-modal');
const billsViewModal = document.getElementById('bills-view-modal');
const partialPaymentModal = document.getElementById('partial-payment-modal');
const fullPaymentModal = document.getElementById('full-payment-modal');
const transactionsModal = document.getElementById('transactions-modal');
const confirmModal = document.getElementById('confirm-modal');

// Elementos dos modais
const closeAccountsModal = document.getElementById('close-accounts-modal');
const closeBillsModal = document.getElementById('close-bills-modal');
const closeBillsViewModal = document.getElementById('close-bills-view-modal');
const closePartialPaymentModal = document.getElementById('close-partial-payment-modal');
const closeFullPaymentModal = document.getElementById('close-full-payment-modal');
const closeTransactionsModal = document.getElementById('close-transactions-modal');
const confirmYesBtn = document.getElementById('confirm-yes-btn');
const confirmNoBtn = document.getElementById('confirm-no-btn');

// Formul√°rios
const accountForm = document.getElementById('account-form');
const billForm = document.getElementById('bill-form');
const accountId = document.getElementById('account-id');
const accountName = document.getElementById('account-name');
const accountBalance = document.getElementById('account-balance');
const billId = document.getElementById('bill-id');
const billName = document.getElementById('bill-name');
const billAmount = document.getElementById('bill-amount');
const billDueDay = document.getElementById('bill-due-day');
const billCategory = document.getElementById('bill-category');

// Filtros de transa√ß√µes
const transactionFilterType = document.getElementById('transaction-filter-type');
const transactionFilterAccount = document.getElementById('transaction-filter-account');
const transactionFilterDate = document.getElementById('transaction-filter-date');
const transactionsList = document.getElementById('transactions-list');
const prevPageBtn = document.getElementById('prev-page-btn');
const nextPageBtn = document.getElementById('next-page-btn');

// Filtros de contas fixas
const billStatusFilter = document.getElementById('bill-status-filter');
const billCategoryFilter = document.getElementById('bill-category-filter');
const billsViewList = document.getElementById('bills-view-list');

// Elementos de pagamento parcial
const partialPaymentAmount = document.getElementById('partial-payment-amount');
const partialPaymentAccount = document.getElementById('partial-payment-account');
const confirmPartialPaymentBtn = document.getElementById('confirm-partial-payment-btn');
const cancelPartialPaymentBtn = document.getElementById('cancel-partial-payment-btn');

// Elementos de pagamento completo
const fullPaymentAccount = document.getElementById('full-payment-account');
const confirmFullPaymentBtn = document.getElementById('confirm-full-payment-btn');
const cancelFullPaymentBtn = document.getElementById('cancel-full-payment-btn');

// Inicializa√ß√£o
document.addEventListener('DOMContentLoaded', () => {
    initializeAuth();
    setupEventListeners();
});

// Configurar listeners de autentica√ß√£o
function initializeAuth() {
    onAuthStateChangedListener((user) => {
        if (user) {
            currentUser = user;
            showAppScreen();
            setupFirestoreListeners();
            addChatMessage('system', 'Bem-vindo ao Dinah! Como posso ajud√°-lo hoje?');
        } else {
            currentUser = null;
            showLoginScreen();
            cleanupFirestoreListeners();
        }
    });
}

// Configurar event listeners
function setupEventListeners() {
    // Login
    loginForm.addEventListener('submit', handleLogin);
    signupBtn.addEventListener('click', handleSignup);
    logoutBtn.addEventListener('click', handleLogout);
    
    // Chat
    sendBtn.addEventListener('click', handleSendMessage);
    chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleSendMessage();
        }
    });

    // Gerenciamento de contas
    manageAccountsBtn.addEventListener('click', () => showModal(accountsModal));
    manageBillsBtn.addEventListener('click', () => showModal(billsModal));
    addAccountBtn.addEventListener('click', () => showModal(accountsModal));
    addBillBtn.addEventListener('click', () => showModal(billsModal));
    
    // Modal de ajuda
    const helpBtn = document.getElementById('help-btn');
    const helpModal = document.getElementById('help-modal');
    const closeHelpModal = document.getElementById('close-help-modal');
    
    if (helpBtn && helpModal && closeHelpModal) {
        helpBtn.addEventListener('click', () => {
            helpModal.classList.remove('hidden');
        });
        
        closeHelpModal.addEventListener('click', () => {
            helpModal.classList.add('hidden');
        });
        
        // Fechar ao clicar fora
        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) {
                helpModal.classList.add('hidden');
            }
        });
    }
    
    viewAllBillsBtn.addEventListener('click', async () => {
        showModal(billsViewModal);
        // Verificar e expandir per√≠odos automaticamente
        await checkAndExpandAllBills();
        filterBills();
    });
    viewAllTransactionsBtn.addEventListener('click', async () => {
        showModal(transactionsModal);
        // Inicializar sistema otimizado de carregamento
        await initializeOptimizedTransactions();
    });

    // Fechar modais
    closeAccountsModal.addEventListener('click', () => hideModal(accountsModal));
    closeBillsModal.addEventListener('click', () => hideModal(billsModal));
    closeBillsViewModal.addEventListener('click', () => hideModal(billsViewModal));
    closePartialPaymentModal.addEventListener('click', () => hideModal(partialPaymentModal));
    closeFullPaymentModal.addEventListener('click', () => hideModal(fullPaymentModal));
    closeTransactionsModal.addEventListener('click', () => {
        hideModal(transactionsModal);
        // Limpar cache quando fechar modal de transa√ß√µes
        clearTransactionCache();
    });
    confirmNoBtn.addEventListener('click', () => hideModal(confirmModal));
    
    // Event listeners para os novos modais
    const closeEditBillModal = document.getElementById('close-edit-bill-modal');
    const cancelEditBillBtn = document.getElementById('cancel-edit-bill-btn');
    const closePaymentHistoryModal = document.getElementById('close-payment-history-modal');
    
    if (closeEditBillModal) {
        closeEditBillModal.addEventListener('click', () => {
            document.getElementById('edit-bill-modal').classList.add('hidden');
        });
    }
    
    if (cancelEditBillBtn) {
        cancelEditBillBtn.addEventListener('click', () => {
            document.getElementById('edit-bill-modal').classList.add('hidden');
        });
    }
    
    if (closePaymentHistoryModal) {
        closePaymentHistoryModal.addEventListener('click', () => {
            document.getElementById('payment-history-modal').classList.add('hidden');
        });
    }
    
    // Fechar modais ao clicar fora
    const editBillModal = document.getElementById('edit-bill-modal');
    const paymentHistoryModal = document.getElementById('payment-history-modal');
    
    if (editBillModal) {
        editBillModal.addEventListener('click', (e) => {
            if (e.target === editBillModal) {
                editBillModal.classList.add('hidden');
            }
        });
    }
    
    if (paymentHistoryModal) {
        paymentHistoryModal.addEventListener('click', (e) => {
            if (e.target === paymentHistoryModal) {
                paymentHistoryModal.classList.add('hidden');
            }
        });
    }

    // Formul√°rios
    accountForm.addEventListener('submit', handleAccountSubmit);
    billForm.addEventListener('submit', handleBillSubmit);

    // Bot√µes de cancelar
    document.getElementById('cancel-account-btn').addEventListener('click', () => {
        resetAccountForm();
        hideModal(accountsModal);
    });
    document.getElementById('cancel-bill-btn').addEventListener('click', () => {
        resetBillForm();
        hideModal(billsModal);
    });

    // Filtros de transa√ß√µes
    transactionFilterType.addEventListener('change', filterTransactions);
    transactionFilterAccount.addEventListener('change', filterTransactions);
    transactionFilterDate.addEventListener('change', filterTransactions);

    // Filtros de contas fixas
    billStatusFilter.addEventListener('change', filterBills);
    billCategoryFilter.addEventListener('change', filterBills);

    // Pagina√ß√£o
    prevPageBtn.addEventListener('click', () => changePage(-1));
    nextPageBtn.addEventListener('click', () => changePage(1));

    // Confirma√ß√£o
    confirmYesBtn.addEventListener('click', handleConfirmDelete);

    // Pagamento parcial
    confirmPartialPaymentBtn.addEventListener('click', handlePartialPayment);
    cancelPartialPaymentBtn.addEventListener('click', () => hideModal(partialPaymentModal));

    // Pagamento completo
    confirmFullPaymentBtn.addEventListener('click', handleFullPayment);
    cancelFullPaymentBtn.addEventListener('click', () => hideModal(fullPaymentModal));

    // Bot√£o para deletar todas as transa√ß√µes
    document.getElementById('delete-all-transactions-btn').addEventListener('click', () => {
        showConfirmModal(
            'Deletar Todas as Transa√ß√µes', 
            '‚ö†Ô∏è ATEN√á√ÉO: Esta a√ß√£o ir√° deletar TODAS as suas transa√ß√µes e resetar os saldos das contas para zero. Esta a√ß√£o n√£o pode ser desfeita e afetar√° apenas os seus dados (n√£o da sua esposa).\n\nTem certeza que deseja continuar?', 
            () => deleteAllTransactions()
        );
    });
}

// Handlers de autentica√ß√£o
async function handleLogin(e) {
    e.preventDefault();
    
    const email = emailInput.value;
    const password = passwordInput.value;
    
    if (!email || !password) {
        showAuthError('Por favor, preencha todos os campos.');
        return;
    }
    
    loginBtn.disabled = true;
    loginBtn.textContent = 'Entrando...';
    
    try {
        const result = await signInUser(email, password);
        if (result.success) {
            hideAuthError();
        } else {
            showAuthError(result.error);
        }
    } catch (error) {
        showAuthError('Erro ao fazer login. Tente novamente.');
    } finally {
        loginBtn.disabled = false;
        loginBtn.textContent = 'Entrar';
    }
}

async function handleSignup() {
    const email = emailInput.value;
    const password = passwordInput.value;
    
    if (!email || !password) {
        showAuthError('Por favor, preencha todos os campos.');
        return;
    }
    
    signupBtn.disabled = true;
    signupBtn.textContent = 'Cadastrando...';
    
    try {
        const result = await signUpUser(email, password);
        if (result.success) {
            hideAuthError();
        } else {
            showAuthError(result.error);
        }
    } catch (error) {
        showAuthError('Erro ao cadastrar. Tente novamente.');
    } finally {
        signupBtn.disabled = false;
        signupBtn.textContent = 'Cadastrar';
    }
}

async function handleLogout() {
    try {
        await signOutUser();
        contextManager.clear();
    } catch (error) {
        console.error('Erro ao fazer logout:', error);
    }
}

// Configurar listeners do Firestore com otimiza√ß√£o para milh√µes de transa√ß√µes
function setupFirestoreListeners() {
    accountsUnsubscribe = onAccountsUpdate((accountsData) => {
        accounts = accountsData;
        renderAccounts();
        renderAccountsManagement();
        updateFinancialSummary();
        updateTransactionFilters();
    });
    
    transactionsUnsubscribe = onTransactionsUpdate((transactionsData) => {
        // Otimiza√ß√£o: Manter apenas as √∫ltimas 50 transa√ß√µes em mem√≥ria para o listener
        // O sistema de pagina√ß√£o carregar√° mais conforme necess√°rio
        transactions = transactionsData.slice(0, 50);
        
        console.log('üíæ Transa√ß√µes recentes carregadas:', transactions.length);
        
        updateFinancialSummary();
        renderRecentTransactions();
        
        // Atualizar status das contas fixas quando transa√ß√µes mudam
        if (fixedBills && fixedBills.length > 0) {
            updateFixedBillsStatus();
        }
    });
    
    fixedBillsUnsubscribe = onFixedBillsUpdate((fixedBillsData) => {
        fixedBills = fixedBillsData;
        updateFixedBillsStatus();
        renderFixedBills();
        renderBillsManagement();
        // Inicializar filtros de contas fixas
        filteredBills = [...fixedBills];
        renderBillsView();
    });
}

// Fun√ß√£o para atualizar status das contas fixas
async function updateFixedBillsStatus() {
    try {
        // Buscar status atualizado de todas as contas fixas
        const billsWithStatus = await getFixedBillsWithStatus();
        
        // Atualizar o array de contas fixas com os status calculados
        fixedBills = billsWithStatus;
        
        // Verificar se alguma conta precisa de expans√£o autom√°tica (processamento no servidor)
        let needsExpansion = false;
        
        for (const bill of fixedBills) {
            // Verificar se a auto-expans√£o est√° habilitada
            if (!bill.autoExpansionEnabled) continue;
            
            // Usar o lastPaidPeriod j√° calculado pela fun√ß√£o getFixedBillStatus (processamento no servidor)
            if (bill.lastPaidPeriod) {
                const initialDate = bill.initialDate?.toDate ? bill.initialDate.toDate() : new Date(bill.initialDate);
                const totalPeriods = bill.totalPeriodsGenerated || 12;
                const periods = calculateAllPeriodsFromInitial(initialDate, bill.dueDay, totalPeriods, false);
                
                // Encontrar √≠ndice do √∫ltimo per√≠odo pago
                const lastPaidIndex = periods.findIndex(p => p.period === bill.lastPaidPeriod.period);
                
                // Calcular per√≠odos restantes
                const periodsRemaining = periods.length - (lastPaidIndex + 1);
                
                // CORRE√á√ÉO: Expans√£o acontece quando restam 5 ou menos per√≠odos
                if (periodsRemaining <= 5) {
                    needsExpansion = true;
                    break; // Sair do loop se encontrou uma conta que precisa expandir
                }
            } else {
                // Se n√£o tem pagamento ainda, verificar se precisa expandir
                const initialDate = bill.initialDate?.toDate ? bill.initialDate.toDate() : new Date(bill.initialDate);
                const totalPeriods = bill.totalPeriodsGenerated || 12;
                const periods = calculateAllPeriodsFromInitial(initialDate, bill.dueDay, totalPeriods, false);
                
                // Se tem poucos per√≠odos restantes, precisa expandir
                if (periods.length <= 5) {
                    needsExpansion = true;
                    break;
                }
            }
        }
        
        if (needsExpansion) {
            await checkAndExpandAllBills();
        }
        
        // Atualizar filtros
        filteredBills = [...fixedBills];
        
        // Re-renderizar componentes
        renderFixedBills();
        renderBillsView();
        
    } catch (error) {
        console.error('Erro ao atualizar status das contas fixas:', error);
        // Em caso de erro, usar c√°lculo local como fallback
        renderFixedBills();
        renderBillsView();
    }
}

// Limpar listeners do Firestore
function cleanupFirestoreListeners() {
    if (accountsUnsubscribe) {
        accountsUnsubscribe();
        accountsUnsubscribe = null;
    }
    if (transactionsUnsubscribe) {
        transactionsUnsubscribe();
        transactionsUnsubscribe = null;
    }
    if (fixedBillsUnsubscribe) {
        fixedBillsUnsubscribe();
        fixedBillsUnsubscribe = null;
    }
}

// Handler principal de mensagens
async function handleSendMessage() {
    const message = chatInput.value.trim();
    if (!message) return;
    
    // Adicionar mensagem do usu√°rio
    addChatMessage('user', message);
    chatInput.value = '';
    
    try {
        // Valida√ß√£o robusta dos dados antes do processamento
        if (!currentUser) {
            throw new Error('Usu√°rio n√£o autenticado');
        }
        
        if (!accounts || !Array.isArray(accounts)) {
            console.warn('accounts inv√°lido:', accounts);
            accounts = [];
        }
        
        if (!fixedBills || !Array.isArray(fixedBills)) {
            console.warn('fixedBills inv√°lido:', fixedBills);
            fixedBills = [];
        }
        
        // Processar mensagem com NLU avan√ßado
        const result = await processMessageAdvanced(message, currentUser, accounts, fixedBills, contextManager);
        
        // Valida√ß√£o do resultado
        if (!result || typeof result !== 'object') {
            throw new Error('Resultado inv√°lido do processamento de mensagem');
        }
        
        // Executar a√ß√£o baseada no resultado
        switch (result.type) {
            case 'action':
                await executeAction(result.payload);
                break;
            case 'clarification':
                addChatMessage('assistant', result.payload.message, result.payload.buttons);
                break;
            case 'response':
                addChatMessage('assistant', result.payload.message);
                break;
            default:
                throw new Error(`Tipo de resultado desconhecido: ${result.type}`);
        }
    } catch (error) {
        console.error('Erro ao processar mensagem:', error);
        
        // Mensagem de erro mais amig√°vel e inteligente
        let errorMessage = '‚ùå Desculpe, ocorreu um erro ao processar sua mensagem. ';
        
        if (error.message.includes('Valor deve ser maior que zero')) {
            errorMessage += 'Por favor, informe um valor v√°lido maior que zero.';
        } else if (error.message.includes('Saldo insuficiente')) {
            errorMessage += 'Saldo insuficiente para realizar esta opera√ß√£o.';
        } else if (error.message.includes('Conta n√£o encontrada')) {
            errorMessage += 'Conta n√£o encontrada. Verifique se a conta existe.';
        } else if (error.message.includes('Usu√°rio n√£o autenticado')) {
            errorMessage += 'Sess√£o expirada. Fa√ßa login novamente.';
        } else if (error.message.includes('Missing or insufficient permissions')) {
            errorMessage += 'Problema de permiss√µes no banco de dados. Tente recarregar a p√°gina.';
        } else if (error.message.includes('Resultado inv√°lido')) {
            errorMessage += 'Erro interno do sistema. Tente reformular sua mensagem.';
        } else {
            errorMessage += 'Tente reformular sua mensagem ou verificar se todos os dados est√£o corretos.';
        }
        
        addChatMessage('assistant', errorMessage);
    }
}

// Executar a√ß√µes do Firestore
async function executeAction(payload) {
    try {
        // Valida√ß√£o robusta do payload
        if (!payload || typeof payload !== 'object') {
            throw new Error('Payload inv√°lido');
        }
        
        if (!payload.action || typeof payload.action !== 'string') {
            throw new Error('A√ß√£o inv√°lida no payload');
        }
        
        if (!payload.data || typeof payload.data !== 'object') {
            throw new Error('Dados inv√°lidos no payload');
        }
        
        switch (payload.action) {
            case 'ADD_TRANSACTION':
                // A data j√° vem como objeto Date do NLU, n√£o precisa converter
                // Se por algum motivo vier como string, converter preservando a data local
                if (payload.data.date && typeof payload.data.date === 'string') {
                    // Extrair componentes da data para evitar problemas de fuso hor√°rio
                    const dateStr = payload.data.date;
                    const dateMatch = dateStr.match(/(\d{4})-(\d{2})-(\d{2})/);
                    if (dateMatch) {
                        const [, year, month, day] = dateMatch;
                        payload.data.date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
                    } else {
                        payload.data.date = new Date(payload.data.date);
                    }
                }
                
                await addTransaction(payload.data);
                const account = accounts.find(acc => acc.id === payload.data.accountId);
                const emoji = payload.data.type === 'expense' ? 'üí∏' : 'üí∞';
                const actionType = payload.data.type === 'expense' ? 'gasto' : 'receita';
                
                let message = `${emoji} **${actionType.charAt(0).toUpperCase() + actionType.slice(1)} registrado com sucesso!**\n\n` +
                    `üí∞ **Valor:** R$ ${payload.data.amount.toFixed(2)}\n` +
                    `üìù **Descri√ß√£o:** ${payload.data.description}\n` +
                    `üè¶ **Conta:** ${account?.name || 'N/A'}\n` +
                    `üìÖ **Data:** ${payload.data.date ? new Date(payload.data.date).toLocaleDateString('pt-BR') : new Date().toLocaleDateString('pt-BR')}`;
                
                // Adicionar informa√ß√£o sobre pagamento parcial
                if (payload.data.isPartialPayment && payload.data.remainingAmount > 0) {
                    message += `\n\n‚ö†Ô∏è **Pagamento parcial:** Ainda restam R$ ${payload.data.remainingAmount.toFixed(2)} para pagar.`;
                }
                
                addChatMessage('assistant', message);
                break;
                
            case 'PAY_FIXED_BILL_CHAT':
                // üß† SISTEMA INTELIGENTE: Processar pagamento restante
                // Usar a fun√ß√£o espec√≠fica para pagamento de contas fixas
                const result = await payFixedBill(
                    payload.data.billId,
                    payload.data.paymentAmount,
                    payload.data.accountId,
                    payload.data.isFullPayment,
                    null, // targetPeriod
                    payload.data.isRemainingPayment
                );
                
                const billAccount = accounts.find(acc => acc.id === payload.data.accountId);
                const billEmoji = 'üí∏';
                const paymentType = payload.data.isRemainingPayment ? 'restante' : 
                                  (payload.data.isFullPayment ? 'completo' : 'parcial');
                
                let billMessage = `${billEmoji} **Gasto registrado com sucesso!**\n\n` +
                    `üí∞ **Valor:** R$ ${payload.data.paymentAmount.toFixed(2)}\n` +
                    `üìù **Descri√ß√£o:** ${payload.data.billDescription} (pagamento ${paymentType})\n` +
                    `üè¶ **Conta:** ${billAccount?.name || 'N/A'}\n` +
                    `üìÖ **Data:** ${new Date().toLocaleDateString('pt-BR')}`;
                
                // Adicionar informa√ß√£o sobre pagamento parcial
                if (!payload.data.isFullPayment && !payload.data.isRemainingPayment && payload.data.remainingAmount > 0) {
                    billMessage += `\n\n‚ö†Ô∏è **Pagamento parcial:** Ainda restam R$ ${payload.data.remainingAmount.toFixed(2)} para pagar.`;
                }
                
                addChatMessage('assistant', billMessage);
                break;
                
            case 'PERFORM_TRANSFER':
                await performTransfer(payload.data.fromAccountId, payload.data.toAccountId, payload.data.amount);
                const fromAccount = accounts.find(acc => acc.id === payload.data.fromAccountId);
                const toAccount = accounts.find(acc => acc.id === payload.data.toAccountId);
                
                addChatMessage('assistant', 
                    `üîÑ **Transfer√™ncia realizada com sucesso!**\n\n` +
                    `üí∞ **Valor:** R$ ${payload.data.amount.toFixed(2)}\n` +
                    `üì§ **De:** ${fromAccount?.name || 'N/A'}\n` +
                    `üì• **Para:** ${toAccount?.name || 'N/A'}\n` +
                    `üìÖ **Data:** ${new Date().toLocaleDateString('pt-BR')}`
                );
                break;
                
            case 'QUERY_SUMMARY':
                const summary = generateAdvancedSummary(payload.data);
                addChatMessage('assistant', summary);
                break;
                
            case 'QUERY_DAILY_EXPENSES':
                const dailyExpenses = generateDailyExpenses(payload.data);
                addChatMessage('assistant', dailyExpenses);
                break;
                
            case 'QUERY_DAILY_INCOME':
                const dailyIncome = generateDailyIncome(payload.data);
                addChatMessage('assistant', dailyIncome);
                break;
                
            case 'QUERY_DAILY_TRANSFERS':
                const dailyTransfers = generateDailyTransfers(payload.data);
                addChatMessage('assistant', dailyTransfers);
                break;
                
            case 'ANALYTICS':
                const analytics = generateAnalytics(payload.data);
                addChatMessage('assistant', analytics);
                break;
                
            case 'ADD_DEBT':
                await addDebt(payload.data);
                addChatMessage('assistant', 
                    `üí≥ **D√≠vida registrada com sucesso!**\n\n` +
                    `üí∞ **Valor:** R$ ${payload.data.amount.toFixed(2)}\n` +
                    `üë§ **Para:** ${payload.data.debtorName}\n` +
                    `üìù **Descri√ß√£o:** ${payload.data.description}\n` +
                    `üìÖ **Data:** ${new Date().toLocaleDateString('pt-BR')}\n\n` +
                    `üí° **Dica:** Use "minhas d√≠vidas" para consultar todas as suas d√≠vidas pendentes.`
                );
                break;
                
            case 'QUERY_DEBTS':
                const debts = await queryDebts(payload.data);
                addChatMessage('assistant', debts);
                break;
                
            case 'MONTHLY_COMPARISON':
                try {
                    const comparison = await analyzeMonthlyComparison(payload.data.userId);
                    addChatMessage('assistant', comparison);
                } catch (error) {
                    console.error('Erro na compara√ß√£o mensal:', error);
                    addChatMessage('assistant', '‚ùå Erro ao gerar compara√ß√£o mensal. Tente novamente.');
                }
                break;
                
            case 'SAVINGS_SUGGESTIONS':
                try {
                    const suggestions = await generateSavingsSuggestions(payload.data.userId);
                    addChatMessage('assistant', suggestions);
                } catch (error) {
                    console.error('Erro nas sugest√µes de economia:', error);
                    addChatMessage('assistant', '‚ùå Erro ao gerar sugest√µes de economia. Tente novamente.');
                }
                break;
                
            default:
                addChatMessage('assistant', 'ü§î A√ß√£o n√£o implementada ainda. Estou aprendendo novas funcionalidades!');
        }
    } catch (error) {
        console.error('Erro ao executar a√ß√£o:', error);
        
        // Mensagem de erro mais espec√≠fica e inteligente
        let errorMessage = '‚ùå **Erro:** ';
        
        if (error.message.includes('Valor deve ser maior que zero')) {
            errorMessage += 'O valor deve ser maior que zero.';
        } else if (error.message.includes('Saldo insuficiente')) {
            errorMessage += 'Saldo insuficiente para realizar esta opera√ß√£o.';
        } else if (error.message.includes('Conta n√£o encontrada')) {
            errorMessage += 'Conta n√£o encontrada.';
        } else if (error.message.includes('Usu√°rio n√£o autenticado')) {
            errorMessage += 'Sess√£o expirada. Fa√ßa login novamente.';
        } else if (error.message.includes('Missing or insufficient permissions')) {
            errorMessage += 'Problema de permiss√µes no banco de dados. Atualize as regras do Firestore ou recarregue a p√°gina.';
        } else if (error.message.includes('Payload inv√°lido') || error.message.includes('A√ß√£o inv√°lida') || error.message.includes('Dados inv√°lidos')) {
            errorMessage += 'Erro interno do sistema. Tente reformular sua mensagem.';
        } else {
            errorMessage += error.message;
        }
        
        addChatMessage('assistant', errorMessage);
    }
}

// Gerar resumo financeiro avan√ßado
function generateAdvancedSummary(data) {
    const currentMonth = new Date().getMonth();
    const currentYear = new Date().getFullYear();
    
    const monthTransactions = transactions.filter(t => {
        if (!t.date) return false;
        
        let transactionDate;
        try {
            if (t.date && typeof t.date.toDate === 'function') {
                transactionDate = t.date.toDate();
            } else if (t.date) {
                transactionDate = new Date(t.date);
            } else {
                return false;
            }
            
            if (isNaN(transactionDate.getTime())) {
                return false;
            }
            
            return transactionDate.getMonth() === currentMonth && 
                   transactionDate.getFullYear() === currentYear;
        } catch (error) {
            console.warn('Erro ao processar data da transa√ß√£o:', error);
            return false;
        }
    });
    
    const income = monthTransactions
        .filter(t => t.type === 'income')
        .reduce((sum, t) => sum + t.amount, 0);
        
    const expenses = monthTransactions
        .filter(t => t.type === 'expense')
        .reduce((sum, t) => sum + t.amount, 0);
    
    const balance = income - expenses;
    const totalBalance = accounts.reduce((sum, acc) => sum + acc.balance, 0);
    
    // Calcular estat√≠sticas por categoria
    const categoryStats = {};
    monthTransactions
        .filter(t => t.type === 'expense')
        .forEach(t => {
            const category = t.category || 'outros';
            categoryStats[category] = (categoryStats[category] || 0) + t.amount;
        });
    
    // Top 3 categorias de gastos
    const topCategories = Object.entries(categoryStats)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 3);
    
    let message = `üìä **Resumo Financeiro do M√™s**\n\n`;
    message += `üí∞ **Receitas:** R$ ${income.toFixed(2)}\n`;
    message += `üí∏ **Despesas:** R$ ${expenses.toFixed(2)}\n`;
    message += `üíµ **Saldo do M√™s:** R$ ${balance.toFixed(2)}\n`;
    message += `üè¶ **Saldo Total:** R$ ${totalBalance.toFixed(2)}\n\n`;
    
    if (topCategories.length > 0) {
        message += `üìà **Top 3 Categorias de Gastos:**\n`;
        topCategories.forEach(([category, amount], index) => {
            const percentage = ((amount / expenses) * 100).toFixed(1);
            message += `${index + 1}. ${category}: R$ ${amount.toFixed(2)} (${percentage}%)\n`;
        });
        message += '\n';
    }
    
    // An√°lise de tend√™ncia
    if (balance > 0) {
        message += `‚úÖ **An√°lise:** Voc√™ est√° com saldo positivo este m√™s! Parab√©ns!`;
    } else if (balance < 0) {
        message += `‚ö†Ô∏è **An√°lise:** Voc√™ est√° com saldo negativo. Considere revisar seus gastos.`;
    } else {
        message += `üìä **An√°lise:** Seus gastos est√£o equilibrados com suas receitas.`;
    }
    
    return message;
}

// Gerar an√°lise avan√ßada
function generateAnalytics(data) {
    const currentMonth = new Date().getMonth();
    const currentYear = new Date().getFullYear();
    
    const monthTransactions = transactions.filter(t => {
        if (!t.date) return false;
        
        let transactionDate;
        try {
            if (t.date && typeof t.date.toDate === 'function') {
                transactionDate = t.date.toDate();
            } else if (t.date) {
                transactionDate = new Date(t.date);
            } else {
                return false;
            }
            
            if (isNaN(transactionDate.getTime())) {
                return false;
            }
            
            return transactionDate.getMonth() === currentMonth && 
                   transactionDate.getFullYear() === currentYear;
        } catch (error) {
            return false;
        }
    });
    
    const expenses = monthTransactions.filter(t => t.type === 'expense');
    const income = monthTransactions.filter(t => t.type === 'income');
    
    // An√°lise por categoria
    const categoryAnalysis = {};
    expenses.forEach(t => {
        const category = t.category || 'outros';
        if (!categoryAnalysis[category]) {
            categoryAnalysis[category] = {
                total: 0,
                count: 0,
                avg: 0
            };
        }
        categoryAnalysis[category].total += t.amount;
        categoryAnalysis[category].count += 1;
    });
    
    // Calcular m√©dias
    Object.values(categoryAnalysis).forEach(cat => {
        cat.avg = cat.total / cat.count;
    });
    
    // Top categorias
    const topCategories = Object.entries(categoryAnalysis)
        .sort(([,a], [,b]) => b.total - a.total)
        .slice(0, 5);
    
    let message = `üìà **An√°lise Detalhada dos Gastos**\n\n`;
    
    if (topCategories.length > 0) {
        message += `üèÜ **Top 5 Categorias de Gastos:**\n`;
        topCategories.forEach(([category, stats], index) => {
            const percentage = ((stats.total / expenses.reduce((sum, t) => sum + t.amount, 0)) * 100).toFixed(1);
            message += `${index + 1}. **${category}**\n`;
            message += `   üí∞ Total: R$ ${stats.total.toFixed(2)}\n`;
            message += `   üìä M√©dia: R$ ${stats.avg.toFixed(2)}\n`;
            message += `   üî¢ Transa√ß√µes: ${stats.count}\n`;
            message += `   üìà Percentual: ${percentage}%\n\n`;
        });
    }
    
    // An√°lise de receitas
    if (income.length > 0) {
        const totalIncome = income.reduce((sum, t) => sum + t.amount, 0);
        const avgIncome = totalIncome / income.length;
        
        message += `üí∞ **An√°lise de Receitas:**\n`;
        message += `üìä Total: R$ ${totalIncome.toFixed(2)}\n`;
        message += `üìà M√©dia por transa√ß√£o: R$ ${avgIncome.toFixed(2)}\n`;
        message += `üî¢ N√∫mero de receitas: ${income.length}\n\n`;
    }
    
    // Insights
    message += `üí° **Insights:**\n`;
    
    if (topCategories.length > 0) {
        const biggestCategory = topCategories[0];
        message += `‚Ä¢ Sua maior categoria de gastos √© **${biggestCategory[0]}** (${((biggestCategory[1].total / expenses.reduce((sum, t) => sum + t.amount, 0)) * 100).toFixed(1)}%)\n`;
    }
    
    const totalExpenses = expenses.reduce((sum, t) => sum + t.amount, 0);
    const totalIncome = income.reduce((sum, t) => sum + t.amount, 0);
    
    if (totalIncome > 0) {
        const savingsRate = ((totalIncome - totalExpenses) / totalIncome * 100).toFixed(1);
        message += `‚Ä¢ Taxa de poupan√ßa: ${savingsRate}%\n`;
    }
    
    if (expenses.length > 0) {
        const avgExpense = totalExpenses / expenses.length;
        message += `‚Ä¢ Gasto m√©dio por transa√ß√£o: R$ ${avgExpense.toFixed(2)}\n`;
    }
    
    return message;
}

// Gerar relat√≥rio de gastos di√°rios
function generateDailyExpenses(data) {
    const targetDate = data.date;
    const targetDateStr = targetDate.toLocaleDateString('pt-BR');
    const isToday = targetDate.toDateString() === new Date().toDateString();
    const isYesterday = targetDate.toDateString() === new Date(Date.now() - 24 * 60 * 60 * 1000).toDateString();
    
    let periodText = '';
    if (isToday) {
        periodText = 'hoje';
    } else if (isYesterday) {
        periodText = 'ontem';
    } else {
        periodText = `em ${targetDateStr}`;
    }
    
    // Filtrar transa√ß√µes do dia espec√≠fico
    const dayTransactions = transactions.filter(t => {
        if (!t.date) return false;
        
        let transactionDate;
        try {
            if (t.date && typeof t.date.toDate === 'function') {
                transactionDate = t.date.toDate();
            } else if (t.date) {
                transactionDate = new Date(t.date);
            } else {
                return false;
            }
            
            if (isNaN(transactionDate.getTime())) {
                return false;
            }
            
            return transactionDate.toDateString() === targetDate.toDateString();
        } catch (error) {
            return false;
        }
    });
    
    // Filtrar apenas gastos
    const expenses = dayTransactions.filter(t => t.type === 'expense');
    const totalExpenses = expenses.reduce((sum, t) => sum + t.amount, 0);
    
    let message = `üí∏ **Gastos ${periodText.charAt(0).toUpperCase() + periodText.slice(1)}**\n\n`;
    
    if (expenses.length === 0) {
        message += `‚úÖ **Nenhum gasto registrado ${periodText}!**\n\n`;
        message += `üéâ Parab√©ns! Voc√™ n√£o gastou nada ${periodText}.`;
        return message;
    }
    
    message += `üí∞ **Total gasto:** R$ ${totalExpenses.toFixed(2)}\n`;
    message += `üìä **N√∫mero de gastos:** ${expenses.length}\n\n`;
    
    // Listar gastos por categoria
    const categoryGroups = {};
    expenses.forEach(expense => {
        const category = expense.category || 'outros';
        if (!categoryGroups[category]) {
            categoryGroups[category] = [];
        }
        categoryGroups[category].push(expense);
    });
    
    message += `üìã **Detalhamento por categoria:**\n\n`;
    
    Object.entries(categoryGroups).forEach(([category, categoryExpenses]) => {
        const categoryTotal = categoryExpenses.reduce((sum, t) => sum + t.amount, 0);
        const percentage = ((categoryTotal / totalExpenses) * 100).toFixed(1);
        
        message += `üè∑Ô∏è **${category.charAt(0).toUpperCase() + category.slice(1)}**\n`;
        message += `   üí∞ Total: R$ ${categoryTotal.toFixed(2)} (${percentage}%)\n`;
        message += `   üî¢ Transa√ß√µes: ${categoryExpenses.length}\n`;
        
        // Listar transa√ß√µes individuais
        categoryExpenses.forEach(expense => {
            const time = expense.date && typeof expense.date.toDate === 'function' 
                ? expense.date.toDate().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })
                : 'N/A';
            message += `   ‚Ä¢ R$ ${expense.amount.toFixed(2)} - ${expense.description} (${time})\n`;
        });
        message += '\n';
    });
    
    // An√°lise r√°pida
    if (totalExpenses > 0) {
        const avgExpense = totalExpenses / expenses.length;
        message += `üìà **An√°lise:**\n`;
        message += `‚Ä¢ Gasto m√©dio por transa√ß√£o: R$ ${avgExpense.toFixed(2)}\n`;
        
        if (expenses.length === 1) {
            message += `‚Ä¢ Voc√™ fez apenas 1 gasto ${periodText}\n`;
        } else {
            message += `‚Ä¢ Voc√™ fez ${expenses.length} gastos ${periodText}\n`;
        }
    }
    
    return message;
}

// Gerar relat√≥rio de receitas di√°rias
function generateDailyIncome(data) {
    const targetDate = data.date;
    const targetDateStr = targetDate.toLocaleDateString('pt-BR');
    const isToday = targetDate.toDateString() === new Date().toDateString();
    const isYesterday = targetDate.toDateString() === new Date(Date.now() - 24 * 60 * 60 * 1000).toDateString();
    
    let periodText = '';
    if (isToday) {
        periodText = 'hoje';
    } else if (isYesterday) {
        periodText = 'ontem';
    } else {
        periodText = `em ${targetDateStr}`;
    }
    
    // Filtrar transa√ß√µes do dia espec√≠fico
    const dayTransactions = transactions.filter(t => {
        if (!t.date) return false;
        
        let transactionDate;
        try {
            if (t.date && typeof t.date.toDate === 'function') {
                transactionDate = t.date.toDate();
            } else if (t.date) {
                transactionDate = new Date(t.date);
            } else {
                return false;
            }
            
            if (isNaN(transactionDate.getTime())) {
                return false;
            }
            
            return transactionDate.toDateString() === targetDate.toDateString();
        } catch (error) {
            return false;
        }
    });
    
    // Filtrar apenas receitas
    const income = dayTransactions.filter(t => t.type === 'income');
    const totalIncome = income.reduce((sum, t) => sum + t.amount, 0);
    
    let message = `üí∞ **Receitas ${periodText.charAt(0).toUpperCase() + periodText.slice(1)}**\n\n`;
    
    if (income.length === 0) {
        message += `üìâ **Nenhuma receita registrada ${periodText}!**\n\n`;
        message += `üí° Voc√™ n√£o recebeu nenhum dinheiro ${periodText}.`;
        return message;
    }
    
    message += `üíµ **Total recebido:** R$ ${totalIncome.toFixed(2)}\n`;
    message += `üìä **N√∫mero de receitas:** ${income.length}\n\n`;
    
    // Listar receitas por categoria
    const categoryGroups = {};
    income.forEach(incomeItem => {
        const category = incomeItem.category || 'outros';
        if (!categoryGroups[category]) {
            categoryGroups[category] = [];
        }
        categoryGroups[category].push(incomeItem);
    });
    
    message += `üìã **Detalhamento por categoria:**\n\n`;
    
    Object.entries(categoryGroups).forEach(([category, categoryIncome]) => {
        const categoryTotal = categoryIncome.reduce((sum, t) => sum + t.amount, 0);
        const percentage = ((categoryTotal / totalIncome) * 100).toFixed(1);
        
        message += `üè∑Ô∏è **${category.charAt(0).toUpperCase() + category.slice(1)}**\n`;
        message += `   üí∞ Total: R$ ${categoryTotal.toFixed(2)} (${percentage}%)\n`;
        message += `   üî¢ Transa√ß√µes: ${categoryIncome.length}\n`;
        
        // Listar transa√ß√µes individuais
        categoryIncome.forEach(incomeItem => {
            const time = incomeItem.date && typeof incomeItem.date.toDate === 'function' 
                ? incomeItem.date.toDate().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })
                : 'N/A';
            message += `   ‚Ä¢ R$ ${incomeItem.amount.toFixed(2)} - ${incomeItem.description} (${time})\n`;
        });
        message += '\n';
    });
    
    // An√°lise r√°pida
    if (totalIncome > 0) {
        const avgIncome = totalIncome / income.length;
        message += `üìà **An√°lise:**\n`;
        message += `‚Ä¢ Receita m√©dia por transa√ß√£o: R$ ${avgIncome.toFixed(2)}\n`;
        
        if (income.length === 1) {
            message += `‚Ä¢ Voc√™ recebeu apenas 1 entrada ${periodText}\n`;
        } else {
            message += `‚Ä¢ Voc√™ recebeu ${income.length} entradas ${periodText}\n`;
        }
    }
    
    return message;
}

// Gerar relat√≥rio de transfer√™ncias di√°rias
function generateDailyTransfers(data) {
    const targetDate = data.date;
    const targetDateStr = targetDate.toLocaleDateString('pt-BR');
    const isToday = targetDate.toDateString() === new Date().toDateString();
    const isYesterday = targetDate.toDateString() === new Date(Date.now() - 24 * 60 * 60 * 1000).toDateString();
    
    let periodText = '';
    if (isToday) {
        periodText = 'hoje';
    } else if (isYesterday) {
        periodText = 'ontem';
    } else {
        periodText = `em ${targetDateStr}`;
    }
    
    // Filtrar transa√ß√µes do dia espec√≠fico
    const dayTransactions = transactions.filter(t => {
        if (!t.date) return false;
        
        let transactionDate;
        try {
            if (t.date && typeof t.date.toDate === 'function') {
                transactionDate = t.date.toDate();
            } else if (t.date) {
                transactionDate = new Date(t.date);
            } else {
                return false;
            }
            
            if (isNaN(transactionDate.getTime())) {
                return false;
            }
            
            return transactionDate.toDateString() === targetDate.toDateString();
        } catch (error) {
            return false;
        }
    });
    
    // Filtrar apenas transfer√™ncias
    const transfers = dayTransactions.filter(t => t.type === 'transfer');
    
    let message = `üîÑ **Transfer√™ncias ${periodText.charAt(0).toUpperCase() + periodText.slice(1)}**\n\n`;
    
    if (transfers.length === 0) {
        message += `üì≠ **Nenhuma transfer√™ncia realizada ${periodText}!**\n\n`;
        message += `üí° Voc√™ n√£o fez nenhuma transfer√™ncia entre suas contas ${periodText}.`;
        return message;
    }
    
    message += `üìä **N√∫mero de transfer√™ncias:** ${transfers.length}\n\n`;
    
    // Listar transfer√™ncias
    message += `üìã **Detalhamento das transfer√™ncias:**\n\n`;
    
    transfers.forEach((transfer, index) => {
        const fromAccount = accounts.find(acc => acc.id === transfer.fromAccountId);
        const toAccount = accounts.find(acc => acc.id === transfer.toAccountId);
        const time = transfer.date && typeof transfer.date.toDate === 'function' 
            ? transfer.date.toDate().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })
            : 'N/A';
        
        message += `${index + 1}. **R$ ${transfer.amount.toFixed(2)}**\n`;
        message += `   üì§ **De:** ${fromAccount?.name || 'Conta n√£o encontrada'}\n`;
        message += `   üì• **Para:** ${toAccount?.name || 'Conta n√£o encontrada'}\n`;
        message += `   üïê **Hor√°rio:** ${time}\n`;
        if (transfer.description) {
            message += `   üìù **Descri√ß√£o:** ${transfer.description}\n`;
        }
        message += '\n';
    });
    
    // An√°lise r√°pida
    if (transfers.length > 0) {
        const totalTransferred = transfers.reduce((sum, t) => sum + t.amount, 0);
        const avgTransfer = totalTransferred / transfers.length;
        
        message += `üìà **An√°lise:**\n`;
        message += `‚Ä¢ Valor total transferido: R$ ${totalTransferred.toFixed(2)}\n`;
        message += `‚Ä¢ Valor m√©dio por transfer√™ncia: R$ ${avgTransfer.toFixed(2)}\n`;
        
        if (transfers.length === 1) {
            message += `‚Ä¢ Voc√™ fez apenas 1 transfer√™ncia ${periodText}\n`;
        } else {
            message += `‚Ä¢ Voc√™ fez ${transfers.length} transfer√™ncias ${periodText}\n`;
        }
    }
    
    return message;
}

// Renderiza√ß√£o da UI
function renderAccounts() {
    accountsList.innerHTML = '';
    
    if (!accounts || accounts.length === 0) {
        accountsList.innerHTML = '<p class="text-gray-400 text-sm">Nenhuma conta cadastrada</p>';
        return;
    }
    
    accounts.forEach(account => {
        const accountElement = document.createElement('div');
        accountElement.className = 'account-card';
        accountElement.innerHTML = `
            <div class="flex justify-between items-center">
                <span class="text-gray-300">${account.name || 'Conta sem nome'}</span>
                <span class="account-balance ${(account.balance || 0) >= 0 ? 'positive' : 'negative'}">
                    R$ ${(account.balance || 0).toFixed(2)}
                </span>
            </div>
        `;
        accountsList.appendChild(accountElement);
    });
}

function renderAccountsManagement() {
    const accountsManagementList = document.getElementById('accounts-management-list');
    accountsManagementList.innerHTML = '';
    
    if (!accounts || accounts.length === 0) {
        accountsManagementList.innerHTML = '<p class="text-gray-400 text-sm">Nenhuma conta cadastrada</p>';
        return;
    }
    
    accounts.forEach(account => {
        const accountElement = document.createElement('div');
        accountElement.className = 'flex justify-between items-center p-3 bg-gray-700 rounded-lg';
        accountElement.innerHTML = `
            <div>
                <span class="text-gray-200 font-medium">${account.name}</span>
                <div class="text-sm text-gray-400">Saldo: R$ ${account.balance.toFixed(2)}</div>
            </div>
            <div class="flex space-x-2">
                <button class="edit-account-btn text-blue-400 hover:text-blue-300 text-sm" data-id="${account.id}">
                    Editar
                </button>
                <button class="delete-account-btn text-red-400 hover:text-red-300 text-sm" data-id="${account.id}">
                    Excluir
                </button>
            </div>
        `;
        
        // Adicionar event listeners
        accountElement.querySelector('.edit-account-btn').addEventListener('click', () => {
            editAccount(account);
        });
        accountElement.querySelector('.delete-account-btn').addEventListener('click', () => {
            showConfirmModal('Excluir Conta', `Tem certeza que deseja excluir a conta "${account.name}"?`, () => deleteAccount(account.id));
        });
        
        accountsManagementList.appendChild(accountElement);
    });
}

function renderFixedBills() {
    fixedBillsSection.innerHTML = '';
    
    if (!fixedBills || fixedBills.length === 0) {
        fixedBillsSection.innerHTML = '<p class="text-gray-400 text-sm">Nenhuma conta fixa cadastrada</p>';
        return;
    }
    
    // Ordenar por valor (mais caras primeiro) e pegar as top 3
    const topBills = [...fixedBills]
        .sort((a, b) => (b.amount || 0) - (a.amount || 0))
        .slice(0, 3);
    
    topBills.forEach(bill => {
        const billElement = document.createElement('div');
        billElement.className = 'fixed-bill-item';
        
        // Usar status calculado pelo Firebase se dispon√≠vel, sen√£o calcular localmente
        let status, statusClass, statusText, totalPaid, remainingAmount;
        
        if (bill.status) {
            // Status j√° calculado pelo Firebase
            status = bill.status;
            statusClass = bill.statusClass;
            statusText = bill.statusText;
            totalPaid = bill.totalPaid || 0;
            remainingAmount = bill.remainingAmount || 0;
        } else {
            // Calcular status localmente (fallback)
            status = calculateBillStatus(bill);
            statusClass = getStatusClass(status);
            statusText = getStatusText(status);
            
            // Calcular valores pagos
            const billTransactions = transactions.filter(t => 
                t.billId === bill.id && 
                t.type === 'expense' &&
                (t.isPartialPayment || t.isBillPayment)
            );
            totalPaid = billTransactions.reduce((sum, t) => sum + t.amount, 0);
            remainingAmount = bill.amount - totalPaid;
        }
        
        billElement.innerHTML = `
            <div class="flex justify-between items-center">
                <span class="text-gray-300">${bill.description || bill.name || 'Conta sem nome'}</span>
                <span class="text-warning">R$ ${(bill.amount || 0).toFixed(2)}</span>
            </div>
            <div class="flex justify-between items-center text-sm">
                <span class="text-gray-400">Vencimento: dia ${bill.dueDay || 'N/A'}</span>
                ${remainingAmount > 0 ? `<span class="${statusClass}">${statusText}</span>` : `<span class="text-green-400 bg-green-900 bg-opacity-30 px-2 py-1 rounded-full text-xs">‚úì Paga</span>`}
            </div>
        `;
        fixedBillsSection.appendChild(billElement);
    });
}

function renderBillsManagement() {
    const billsManagementList = document.getElementById('bills-management-list');
    billsManagementList.innerHTML = '';
    
    if (!fixedBills || fixedBills.length === 0) {
        billsManagementList.innerHTML = '<p class="text-gray-400 text-sm">Nenhuma conta fixa cadastrada</p>';
        return;
    }
    
    fixedBills.forEach(bill => {
        const billElement = document.createElement('div');
        billElement.className = 'flex justify-between items-center p-3 bg-gray-700 rounded-lg';
        billElement.innerHTML = `
            <div>
                <span class="text-gray-200 font-medium">${bill.description || bill.name}</span>
                <div class="text-sm text-gray-400">R$ ${bill.amount.toFixed(2)} - Vencimento: dia ${bill.dueDay}</div>
            </div>
            <div class="flex space-x-2">
                <button class="edit-bill-btn text-blue-400 hover:text-blue-300 text-sm" data-id="${bill.id}">
                    Editar
                </button>
                <button class="delete-bill-btn text-red-400 hover:text-red-300 text-sm" data-id="${bill.id}">
                    Excluir
                </button>
            </div>
        `;
        
        // Adicionar event listeners
        billElement.querySelector('.edit-bill-btn').addEventListener('click', () => {
            editBill(bill);
        });
        billElement.querySelector('.delete-bill-btn').addEventListener('click', () => {
            showConfirmModal('Excluir Conta Fixa', `Tem certeza que deseja excluir a conta fixa "${bill.description || bill.name}"?`, () => deleteFixedBill(bill.id));
        });
        
        billsManagementList.appendChild(billElement);
    });
}

function renderBillsView() {
    billsViewList.innerHTML = '';
    
    if (!filteredBills || filteredBills.length === 0) {
        billsViewList.innerHTML = '<p class="text-gray-400 text-center py-8">Nenhuma conta fixa encontrada</p>';
        return;
    }
    
    // Ordenar por prioridade: vencidas primeiro, depois vence hoje, depois quase vencendo, depois pendentes
    const sortedBills = [...filteredBills].sort((a, b) => {
        const statusA = calculateBillStatus(a);
        const statusB = calculateBillStatus(b);
        
        const priorityOrder = ['overdue', 'due-today', 'due-soon', 'pending', 'partial', 'paid'];
        const priorityA = priorityOrder.indexOf(statusA);
        const priorityB = priorityOrder.indexOf(statusB);
        
        if (priorityA !== priorityB) {
            return priorityA - priorityB;
        }
        
        // Se mesmo status, ordenar por valor (mais caras primeiro)
        return (b.amount || 0) - (a.amount || 0);
    });
    
    sortedBills.forEach(bill => {
        const billElement = document.createElement('div');
        billElement.className = 'bg-gray-700 rounded-lg p-4 mb-4';
        
        // Usar status calculado pelo Firebase se dispon√≠vel, sen√£o calcular localmente
        let status, statusClass, statusText, totalPaid, remainingAmount, canPay;
        
        if (bill.status) {
            // Status j√° calculado pelo Firebase
            status = bill.status;
            statusClass = bill.statusClass;
            statusText = bill.statusText;
            totalPaid = bill.totalPaid || 0;
            remainingAmount = bill.remainingAmount || 0;
            canPay = bill.canPay !== false; // Sempre true quando h√° valor restante
        } else {
            // Calcular status localmente (fallback)
            status = calculateBillStatus(bill);
            statusClass = getStatusClass(status);
            statusText = getStatusText(status);
            
            // Calcular valores pagos
            const billTransactions = transactions.filter(t => 
                t.billId === bill.id && 
                t.type === 'expense' &&
                (t.isPartialPayment || t.isBillPayment)
            );
            totalPaid = billTransactions.reduce((sum, t) => sum + t.amount, 0);
            remainingAmount = bill.amount - totalPaid;
            canPay = true; // Sempre pode pagar quando h√° valor restante
        }
        
        // Determinar texto do bot√£o de pagamento
        let paymentButtonText = 'Pagar';
        if (remainingAmount > 0) {
            if (status === 'overdue') {
                paymentButtonText = 'Pagar Vencida';
            } else if (status === 'partial') {
                paymentButtonText = 'Completar Pagamento';
            } else if (status === 'due-soon') {
                paymentButtonText = 'Pagar Antecipado';
            } else {
                paymentButtonText = 'Pagar';
            }
        } else {
            paymentButtonText = 'Pagar Pr√≥ximo';
        }
        
        // Obter √∫ltimo per√≠odo pago para mostrar
        const lastPaidPeriod = bill.lastPaidPeriod;
        const lastPaidText = lastPaidPeriod ? 
            `√öltimo pago: ${lastPaidPeriod.monthName} ${lastPaidPeriod.year}` : 
            'Nenhum pagamento';
        
        billElement.innerHTML = `
            <div class="flex justify-between items-start mb-3">
                <div>
                    <h4 class="text-lg font-medium text-white">${bill.description || bill.name}</h4>
                    <div class="text-sm text-gray-400 mt-1">
                        <span>Valor: R$ ${bill.amount.toFixed(2)}</span>
                        <span class="mx-2">‚Ä¢</span>
                        <span>Vencimento: dia ${bill.dueDay}</span>
                        <span class="mx-2">‚Ä¢</span>
                        <span>Categoria: ${getCategoryName(bill.category)}</span>
                    </div>
                </div>
                <div class="flex space-x-2">
                    <button class="edit-bill-btn text-blue-400 hover:text-blue-300 text-sm px-2 py-1 rounded" data-id="${bill.id}">
                        ‚úèÔ∏è Editar
                    </button>
                    <button class="delete-bill-btn text-red-400 hover:text-red-300 text-sm px-2 py-1 rounded" data-id="${bill.id}">
                        üóëÔ∏è Excluir
                    </button>
                </div>
            </div>
            
            <div class="flex justify-between items-center mb-3">
                <div class="flex items-center space-x-4">
                    <span class="${statusClass} font-medium">${statusText}</span>
                    <span class="text-gray-400 text-sm">${lastPaidText}</span>
                </div>
                <div class="text-right">
                    <div class="text-sm text-gray-400">
                        Pago: R$ ${totalPaid.toFixed(2)}
                    </div>
                    <div class="text-sm ${remainingAmount > 0 ? 'text-red-400' : 'text-green-400'}">
                        Restante: R$ ${remainingAmount.toFixed(2)}
                    </div>
                </div>
            </div>
            
            <div class="flex justify-between items-center">
                <div class="flex space-x-2">
                    <button class="pay-bill-btn bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md transition duration-200 text-sm" data-id="${bill.id}">
                        ${paymentButtonText}
                    </button>
                    <button class="pay-partial-btn bg-yellow-600 hover:bg-yellow-700 text-white px-4 py-2 rounded-md transition duration-200 text-sm" data-id="${bill.id}">
                        Pagamento Parcial
                    </button>
                    <button class="view-history-btn bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md transition duration-200 text-sm" data-id="${bill.id}">
                        üìä Hist√≥rico
                    </button>
                </div>
                <div class="text-xs text-gray-500">
                    ID: ${bill.id.substring(0, 8)}...
                </div>
            </div>
        `;
        
        // Adicionar event listeners
        billElement.querySelector('.edit-bill-btn').addEventListener('click', () => {
            editBill(bill);
        });
        
        billElement.querySelector('.delete-bill-btn').addEventListener('click', () => {
            showConfirmModal('Excluir Conta Fixa', `Tem certeza que deseja excluir a conta fixa "${bill.description || bill.name}"?`, () => deleteFixedBill(bill.id));
        });
        
        billElement.querySelector('.pay-bill-btn').addEventListener('click', () => {
            handleFullPaymentModal(bill);
        });
        
        billElement.querySelector('.pay-partial-btn').addEventListener('click', () => {
            handlePartialPaymentModal(bill);
        });
        
        billElement.querySelector('.view-history-btn').addEventListener('click', () => {
            showPaymentHistory(bill.id);
        });
        
        billsViewList.appendChild(billElement);
    });
}

function renderRecentTransactions() {
    console.log('üé® Renderizando transa√ß√µes recentes...');
    
    if (!recentTransactions) {
        console.error('‚ùå Elemento recentTransactions n√£o encontrado!');
        return;
    }
    
    recentTransactions.innerHTML = '';
    
    if (!transactions || transactions.length === 0) {
        console.log('‚ö†Ô∏è Nenhuma transa√ß√£o encontrada');
        recentTransactions.innerHTML = '<p class="text-gray-400 text-sm">Nenhuma transa√ß√£o recente</p>';
        return;
    }
    
    const recent = transactions.slice(0, 5);
    console.log('üìÑ Transa√ß√µes recentes para exibir:', recent.length);
    
    recent.forEach((transaction, index) => {
        console.log(`üí≥ Renderizando transa√ß√£o ${index + 1}:`, {
            id: transaction.id,
            description: transaction.description,
            amount: transaction.amount,
            type: transaction.type,
            accountName: transaction.accountName,
            date: transaction.date
        });
        
        const transactionElement = document.createElement('div');
        transactionElement.className = 'text-sm';
        
        const amount = transaction.amount || 0;
        const isExpense = transaction.type === 'expense';
        const amountClass = isExpense ? 'text-red-400' : 'text-green-400';
        const amountPrefix = isExpense ? '-' : '+';
        
        const html = `
            <div class="flex justify-between items-center">
                <span class="text-gray-300 truncate">${transaction.description || 'Sem descri√ß√£o'}</span>
                <span class="${amountClass} font-medium">${amountPrefix}R$ ${amount.toFixed(2)}</span>
            </div>
            <div class="text-xs text-gray-400">${transaction.accountName || 'Conta n√£o especificada'} ‚Ä¢ ${formatDate(transaction.date)}</div>
        `;
        
        console.log(`üìù HTML gerado para transa√ß√£o ${index + 1}:`, html);
        transactionElement.innerHTML = html;
        recentTransactions.appendChild(transactionElement);
    });
    
}

function renderTransactions() {
    console.log('üé® Renderizando transa√ß√µes no modal...');
    
    transactionsList.innerHTML = '';
    
    if (!filteredTransactions || filteredTransactions.length === 0) {
        console.log('‚ö†Ô∏è Nenhuma transa√ß√£o filtrada encontrada');
        transactionsList.innerHTML = '<p class="text-gray-400 text-center py-8">Nenhuma transa√ß√£o encontrada</p>';
        return;
    }
    
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const pageTransactions = filteredTransactions.slice(startIndex, endIndex);
    
    console.log('üìÑ Transa√ß√µes da p√°gina atual:', pageTransactions.length);
    
    // Criar container com altura fixa e scroll
    const container = document.createElement('div');
    container.className = 'h-96 overflow-y-auto space-y-2 pr-2'; // Altura fixa com scroll
    
    pageTransactions.forEach((transaction, index) => {
        console.log(`üí≥ Renderizando transa√ß√£o ${index + 1} no modal:`, {
            id: transaction.id,
            description: transaction.description,
            amount: transaction.amount,
            type: transaction.type
        });
        
        const transactionElement = document.createElement('div');
        transactionElement.className = 'flex justify-between items-center p-3 bg-gray-700 rounded-lg hover:bg-gray-600 transition-colors';
        
        const amount = transaction.amount || 0;
        const isExpense = transaction.type === 'expense';
        const amountClass = isExpense ? 'text-red-400' : 'text-green-400';
        const amountPrefix = isExpense ? '-' : '+';
        
        transactionElement.innerHTML = `
            <div class="flex-1">
                <div class="text-gray-200 font-medium">${transaction.description || 'Sem descri√ß√£o'}</div>
                <div class="text-sm text-gray-400">${transaction.accountName || 'Conta n√£o especificada'} ‚Ä¢ ${formatDate(transaction.date)}</div>
            </div>
            <div class="text-right">
                <div class="${amountClass} font-medium">${amountPrefix}R$ ${amount.toFixed(2)}</div>
                <div class="text-xs text-gray-400">${getTransactionTypeLabel(transaction.type)}</div>
            </div>
            <div class="ml-3">
                <button onclick="handleRefund('${transaction.id}')" class="refund-btn text-xs">
                    Estornar
                </button>
            </div>
        `;
        container.appendChild(transactionElement);
    });
    
    // Adicionar bot√£o "Carregar Mais" se necess√°rio
    if (hasMoreTransactions && currentPage * itemsPerPage >= filteredTransactions.length) {
        const loadMoreButton = document.createElement('div');
        loadMoreButton.className = 'text-center py-4';
        loadMoreButton.innerHTML = `
            <button onclick="loadMoreTransactions()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded">
                üìÑ Carregar Mais Transa√ß√µes
            </button>
        `;
        container.appendChild(loadMoreButton);
    }
    
    transactionsList.appendChild(container);
    
    
    updatePagination();
}

function updatePagination() {
    const total = filteredTransactions.length;
    const start = (currentPage - 1) * itemsPerPage + 1;
    const end = Math.min(currentPage * itemsPerPage, total);
    
    document.getElementById('transactions-start').textContent = start;
    document.getElementById('transactions-end').textContent = end;
    document.getElementById('transactions-total').textContent = total;
    
    prevPageBtn.disabled = currentPage === 1;
    nextPageBtn.disabled = end >= total;
}

// Fun√ß√£o otimizada para renderizar transa√ß√µes com scroll virtual
function renderTransactionsOptimized() {
    console.log('üé® Renderizando transa√ß√µes otimizadas...');
    
    transactionsList.innerHTML = '';
    
    if (!filteredTransactions || filteredTransactions.length === 0) {
        console.log('‚ö†Ô∏è Nenhuma transa√ß√£o filtrada encontrada');
        transactionsList.innerHTML = '<p class="text-gray-400 text-center py-8">Nenhuma transa√ß√£o encontrada</p>';
        return;
    }
    
    // Criar container com altura fixa e scroll
    const container = document.createElement('div');
    container.className = 'h-96 overflow-y-auto space-y-2 pr-2'; // Altura fixa com scroll
    
    // Renderizar apenas as transa√ß√µes vis√≠veis (primeira p√°gina)
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const pageTransactions = filteredTransactions.slice(startIndex, endIndex);
    
    console.log(`üìÑ Renderizando ${pageTransactions.length} transa√ß√µes (p√°gina ${currentPage})`);
    
    pageTransactions.forEach(transaction => {
        const transactionElement = document.createElement('div');
        transactionElement.className = 'bg-gray-700 rounded-lg p-4 hover:bg-gray-600 transition-colors';
        
        const date = transaction.date?.toDate ? transaction.date.toDate() : new Date(transaction.date);
        const formattedDate = date.toLocaleDateString('pt-BR');
        const formattedTime = date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
        
        const amountClass = transaction.type === 'income' ? 'text-green-400' : 'text-red-400';
        const amountPrefix = transaction.type === 'income' ? '+' : '-';
        
        transactionElement.innerHTML = `
            <div class="flex justify-between items-start">
                <div class="flex-1">
                    <div class="flex items-center space-x-2">
                        <span class="text-sm text-gray-400">${formattedDate}</span>
                        <span class="text-xs text-gray-500">${formattedTime}</span>
                    </div>
                    <h4 class="font-medium text-gray-200 mt-1">${transaction.description}</h4>
                    <p class="text-sm text-gray-400">${transaction.accountName}</p>
                    <span class="inline-block bg-gray-600 text-gray-300 text-xs px-2 py-1 rounded mt-2">
                        ${transaction.category || 'outros'}
                    </span>
                </div>
                <div class="text-right">
                    <div class="${amountClass} font-semibold text-lg">
                        ${amountPrefix}R$ ${transaction.amount.toFixed(2)}
                    </div>
                    <button onclick="handleRefund('${transaction.id}')" 
                            class="text-red-400 hover:text-red-300 text-sm mt-1">
                        Estornar
                    </button>
                </div>
            </div>
        `;
        
        container.appendChild(transactionElement);
    });
    
    // Adicionar bot√£o "Carregar Mais" se necess√°rio
    if (hasMoreTransactions && !isLoadingMore) {
        const loadMoreButton = document.createElement('div');
        loadMoreButton.className = 'text-center py-4';
        loadMoreButton.innerHTML = `
            <button onclick="loadMoreTransactions()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded transition-colors">
                üìÑ Carregar Mais Transa√ß√µes
            </button>
        `;
        container.appendChild(loadMoreButton);
    }
    
    transactionsList.appendChild(container);
    
    // Atualizar informa√ß√µes de pagina√ß√£o
    updatePaginationInfo();
}

// Fun√ß√£o para atualizar informa√ß√µes de pagina√ß√£o
function updatePaginationInfo() {
    const start = (currentPage - 1) * itemsPerPage + 1;
    const end = Math.min(currentPage * itemsPerPage, filteredTransactions.length);
    const total = filteredTransactions.length;
    
    document.getElementById('transactions-start').textContent = start;
    document.getElementById('transactions-end').textContent = end;
    document.getElementById('transactions-total').textContent = total;
    
    const prevPageBtn = document.getElementById('prev-page-btn');
    const nextPageBtn = document.getElementById('next-page-btn');
    
    prevPageBtn.disabled = currentPage === 1;
    nextPageBtn.disabled = end >= total && !hasMoreTransactions;
}

// Fun√ß√£o para limpar cache automaticamente
function clearTransactionCache() {
    console.log('üßπ Limpando cache de transa√ß√µes...');
    allLoadedTransactions = [];
    filteredTransactions = [];
    lastLoadedDoc = null;
    currentPage = 1;
    hasMoreTransactions = true;
    isLoadingMore = false;
    
    // Limpar timer se existir
    if (cacheCleanupTimer) {
        clearTimeout(cacheCleanupTimer);
        cacheCleanupTimer = null;
    }
}

// Fun√ß√£o para agendar limpeza autom√°tica do cache
function scheduleCacheCleanup() {
    // Limpar cache ap√≥s 5 minutos de inatividade
    if (cacheCleanupTimer) {
        clearTimeout(cacheCleanupTimer);
    }
    
    cacheCleanupTimer = setTimeout(() => {
        console.log('‚è∞ Limpeza autom√°tica do cache executada');
        clearTransactionCache();
    }, 5 * 60 * 1000); // 5 minutos
}

// Fun√ß√£o para inicializar o sistema otimizado de transa√ß√µes
async function initializeOptimizedTransactions() {
    try {
        // Limpar cache anterior
        clearTransactionCache();
        
        // Carregar primeira p√°gina de transa√ß√µes
        await loadMoreTransactionsInternal();
        
        // Agendar limpeza autom√°tica
        scheduleCacheCleanup();
        
        console.log('‚úÖ Sistema otimizado de transa√ß√µes inicializado');
    } catch (error) {
        console.error('Erro ao inicializar transa√ß√µes otimizadas:', error);
        showErrorModal('Erro ao carregar transa√ß√µes. Tente novamente.');
    }
}

function changePage(delta) {
    const newPage = currentPage + delta;
    const maxPage = Math.ceil(filteredTransactions.length / itemsPerPage);
    
    if (newPage >= 1 && newPage <= maxPage) {
        currentPage = newPage;
        renderTransactionsOptimized();
    }
}

// Fun√ß√£o otimizada para carregar transa√ß√µes com pagina√ß√£o inteligente
async function loadMoreTransactionsInternal() {
    if (isLoadingMore || !hasMoreTransactions) return;
    
    try {
        isLoadingMore = true;
        
        // Mostrar indicador de carregamento
        const loadingElement = document.createElement('div');
        loadingElement.className = 'text-center py-4 text-gray-400';
        loadingElement.innerHTML = 'üîÑ Carregando mais transa√ß√µes...';
        transactionsList.appendChild(loadingElement);
        
        // Carregar transa√ß√µes usando cursor-based pagination
        const result = await loadOlderTransactions(lastLoadedDoc, itemsPerPage);
        
        if (result.transactions.length > 0) {
            // Sistema otimizado: substituir cache em vez de acumular
            if (allLoadedTransactions.length === 0) {
                // Primeira carga: adicionar transa√ß√µes
                allLoadedTransactions = [...result.transactions];
            } else {
                // Carregamentos subsequentes: substituir por novas transa√ß√µes
                allLoadedTransactions = [...result.transactions];
            }
            
            // Agendar limpeza autom√°tica ap√≥s cada carregamento
            scheduleCacheCleanup();
            
            // Atualizar cursor para pr√≥xima p√°gina
            lastLoadedDoc = result.lastDoc;
            hasMoreTransactions = result.hasMore;
            
            // Aplicar filtros atuais
            applyCurrentFilters();
            
            // Renderizar transa√ß√µes
            renderTransactionsOptimized();
            
            console.log(`üìÑ Carregadas ${result.transactions.length} transa√ß√µes. Total em cache: ${allLoadedTransactions.length}`);
        } else {
            hasMoreTransactions = false;
            console.log('üìÑ N√£o h√° mais transa√ß√µes para carregar');
        }
        
        // Remover indicador de carregamento
        const loadingElements = transactionsList.querySelectorAll('.text-center.py-4.text-gray-400');
        loadingElements.forEach(el => {
            if (el.parentNode) {
                el.parentNode.removeChild(el);
            }
        });
        
    } catch (error) {
        console.error('Erro ao carregar mais transa√ß√µes:', error);
        showErrorModal('Erro ao carregar mais transa√ß√µes. Tente novamente.');
    } finally {
        isLoadingMore = false;
    }
}

// Fun√ß√£o otimizada para filtrar transa√ß√µes
// Fun√ß√£o para aplicar filtros atuais
function applyCurrentFilters() {
    const typeFilter = transactionFilterType.value;
    const accountFilter = transactionFilterAccount.value;
    const dateFilter = transactionFilterDate.value;
    
    filteredTransactions = allLoadedTransactions.filter(transaction => {
        return passesCurrentFilters(transaction);
    });
}

// Fun√ß√£o auxiliar para verificar se uma transa√ß√£o passa nos filtros atuais
function passesCurrentFilters(transaction) {
    const typeFilter = transactionFilterType.value;
    const accountFilter = transactionFilterAccount.value;
    const dateFilter = transactionFilterDate.value;
    
    // Filtro por tipo
    if (typeFilter && transaction.type !== typeFilter) {
        return false;
    }
    
    // Filtro por conta
    if (accountFilter && transaction.accountId !== accountFilter) {
        return false;
    }
    
    // Filtro por data
    if (dateFilter) {
        const transactionDate = transaction.date?.toDate ? transaction.date.toDate() : new Date(transaction.date);
        const filterDate = new Date(dateFilter);
        
        if (transactionDate.toDateString() !== filterDate.toDateString()) {
            return false;
        }
    }
    
    return true;
}

// Fun√ß√£o otimizada para filtrar transa√ß√µes (compatibilidade)
function filterTransactions() {
    console.log('üéØ Filtros aplicados:', { 
        typeFilter: transactionFilterType.value, 
        accountFilter: transactionFilterAccount.value, 
        dateFilter: transactionFilterDate.value 
    });
    
    // Usar cache local limitado
    filteredTransactions = allLoadedTransactions.filter(transaction => {
        return passesCurrentFilters(transaction);
    });
    
    currentPage = 1;
    renderTransactionsOptimized();
}

function filterBills() {
    const statusFilter = billStatusFilter.value;
    const categoryFilter = billCategoryFilter.value;
    
    filteredBills = fixedBills.filter(bill => {
        // Filtro por status
        if (statusFilter) {
            const status = bill.status || calculateBillStatus(bill);
            if (status !== statusFilter) {
                return false;
            }
        }
        
        // Filtro por categoria
        if (categoryFilter && bill.category !== categoryFilter) {
            return false;
        }
        
        return true;
    });
    
    renderBillsView();
}

function updateTransactionFilters() {
    const accountSelect = transactionFilterAccount;
    accountSelect.innerHTML = '<option value="">Todas as contas</option>';
    
    accounts.forEach(account => {
        const option = document.createElement('option');
        option.value = account.id;
        option.textContent = account.name;
        accountSelect.appendChild(option);
    });
}

// Fun√ß√µes de pagamento de contas fixas
function handleFullPaymentModal(bill) {
    currentBillForPayment = bill;
    
    // Obter informa√ß√µes completas da conta fixa para permitir pagamento antecipado
    getFixedBillInfoOptimized(bill.id).then(billInfo => {
        // Verificar se h√° per√≠odos dispon√≠veis para pagamento
        const availablePeriods = billInfo.nextPeriodsToPay;
        
        if (availablePeriods.length === 0) {
            showWarningModal('N√£o h√° per√≠odos dispon√≠veis para pagamento');
            return;
        }
        
        // CORRE√á√ÉO: Identificar o per√≠odo atual (primeiro per√≠odo com valor restante)
        let currentPeriod = availablePeriods.find(period => period.isCurrentMonth && period.remainingAmount > 0);
        
        // Se n√£o h√° per√≠odo atual com valor restante, verificar se h√° pagamento parcial em per√≠odo futuro
        if (!currentPeriod) {
            // Buscar pr√≥ximo per√≠odo com pagamento parcial (que deve ser tratado como per√≠odo atual)
            currentPeriod = availablePeriods.find(period => 
                period.remainingAmount > 0 && 
                period.remainingAmount < bill.amount && 
                period.totalPaid > 0
            );
        }
        
        if (currentPeriod) {
            // PAGAMENTO NORMAL: H√° per√≠odo atual com valor restante - pagar diretamente
            const remainingAmount = currentPeriod.remainingAmount;
            
            // Preencher informa√ß√µes no modal
            document.getElementById('full-payment-bill-name').textContent = bill.description || bill.name;
            document.getElementById('full-payment-total-amount').textContent = `R$ ${bill.amount.toFixed(2)}`;
            document.getElementById('full-payment-paid-amount').textContent = `R$ ${currentPeriod.totalPaid.toFixed(2)}`;
            document.getElementById('full-payment-amount-to-pay').textContent = `R$ ${remainingAmount.toFixed(2)}`;
            
            // Preencher select de contas (apenas contas com saldo suficiente)
            fullPaymentAccount.innerHTML = '';
            const accountsWithBalance = accounts.filter(account => account.balance >= remainingAmount);
            
            if (accountsWithBalance.length === 0) {
                showWarningModal('Nenhuma conta possui saldo suficiente para este pagamento');
                return;
            }
            
            accountsWithBalance.forEach(account => {
                const option = document.createElement('option');
                option.value = account.id;
                option.textContent = `${account.name} (R$ ${account.balance.toFixed(2)})`;
                fullPaymentAccount.appendChild(option);
            });
            
            showModal(fullPaymentModal);
        } else {
            // PAGAMENTO ANTECIPADO: N√£o h√° per√≠odo atual com valor restante - mostrar modal de sele√ß√£o
            // Filtrar apenas per√≠odos futuros (n√£o o atual)
            const futurePeriods = availablePeriods.filter(period => !period.isCurrentMonth && period.remainingAmount > 0);
            
            if (futurePeriods.length === 0) {
                showInfoModal('N√£o h√° per√≠odos futuros dispon√≠veis para pagamento antecipado');
                return;
            }
            
            showPeriodSelectionModal(bill, futurePeriods);
        }
        
    }).catch(error => {
        showErrorModal(`Erro ao carregar dados da conta: ${error.message}`);
    });
}

// Fun√ß√£o para mostrar modal de sele√ß√£o de per√≠odos
function showPeriodSelectionModal(bill, availablePeriods) {
    // Criar modal dinamicamente
    const modalHtml = `
        <div id="period-selection-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-gray-800 rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto">
                <div class="p-6">
                    <div class="flex justify-between items-center mb-6">
                        <h3 class="text-xl font-semibold text-white">Pagamento Antecipado</h3>
                        <button id="close-period-selection-modal" class="text-gray-400 hover:text-white text-2xl">√ó</button>
                    </div>
                    
                    <div class="mb-4">
                        <h4 class="text-lg font-medium text-white mb-2">${bill.description || bill.name}</h4>
                        <div class="text-sm text-gray-400">Valor: R$ ${bill.amount.toFixed(2)} ‚Ä¢ Vencimento: dia ${bill.dueDay}</div>
                    </div>
                    
                    <div class="space-y-3 mb-6">
                        <h5 class="text-md font-semibold text-white">Selecione o per√≠odo para pagamento antecipado:</h5>
                        ${availablePeriods.map((period, index) => `
                            <div class="period-option p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600 transition duration-200" data-period="${period.period}" data-index="${index}">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <div class="text-white font-medium">${period.monthName} ${period.year}</div>
                                        <div class="text-sm text-gray-400">Per√≠odo: ${period.period}</div>
                                    </div>
                                    <div class="text-right">
                                        <div class="text-sm text-gray-400">Pago: R$ ${period.totalPaid.toFixed(2)}</div>
                                        <div class="text-sm ${period.remainingAmount > 0 ? 'text-red-400' : 'text-green-400'}">
                                            Restante: R$ ${period.remainingAmount.toFixed(2)}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="flex space-x-3">
                        <button id="confirm-period-payment-btn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md transition duration-200 flex-1" disabled>
                            Pagar Per√≠odo Selecionado
                        </button>
                        <button id="cancel-period-selection-btn" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md transition duration-200 flex-1">
                            Cancelar
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Adicionar modal ao DOM
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    const modal = document.getElementById('period-selection-modal');
    const closeBtn = document.getElementById('close-period-selection-modal');
    const cancelBtn = document.getElementById('cancel-period-selection-btn');
    const confirmBtn = document.getElementById('confirm-period-payment-btn');
    const periodOptions = modal.querySelectorAll('.period-option');
    
    let selectedPeriod = null;
    
    // Event listeners
    closeBtn.addEventListener('click', () => {
        modal.remove();
    });
    
    cancelBtn.addEventListener('click', () => {
        modal.remove();
    });
    
    // Sele√ß√£o de per√≠odo
    periodOptions.forEach(option => {
        option.addEventListener('click', () => {
            // Remover sele√ß√£o anterior
            periodOptions.forEach(opt => opt.classList.remove('ring-2', 'ring-blue-500'));
            
            // Selecionar novo per√≠odo
            option.classList.add('ring-2', 'ring-blue-500');
            selectedPeriod = availablePeriods[parseInt(option.dataset.index)];
            confirmBtn.disabled = false;
        });
    });
    
    // Confirmar pagamento
    confirmBtn.addEventListener('click', () => {
        if (selectedPeriod) {
            modal.remove();
            handlePeriodPayment(bill, selectedPeriod);
        }
    });
    
    // Fechar ao clicar fora
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.remove();
        }
    });
}

// Fun√ß√£o para processar pagamento de per√≠odo espec√≠fico
async function handlePeriodPayment(bill, period) {
    try {
        // Mostrar modal de confirma√ß√£o bonito
        const confirmMessage = `Confirmar pagamento de R$ ${bill.amount.toFixed(2)} para o per√≠odo ${period.monthName} ${period.year}?`;
        
        const confirmed = await showConfirmationModal(
            'Confirmar Pagamento Antecipado', 
            confirmMessage, 
            'üí≥'
        );
        
        if (confirmed) {
            // Mostrar modal de sele√ß√£o de conta
            showAccountSelectionModal(bill, period);
        }
    } catch (error) {
        await showErrorModal(`Erro ao realizar pagamento: ${error.message}`);
    }
}

// Fun√ß√£o para mostrar modal de sele√ß√£o de conta
function showAccountSelectionModal(bill, period) {
    // Filtrar apenas contas com saldo suficiente
    const accountsWithBalance = accounts.filter(account => account.balance >= bill.amount);
    
    if (accountsWithBalance.length === 0) {
        showWarningModal(`Nenhuma conta possui saldo suficiente para pagar R$ ${bill.amount.toFixed(2)}`);
        return;
    }
    
    // Criar modal dinamicamente
    const modalHtml = `
        <div id="account-selection-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-gray-800 rounded-lg shadow-xl max-w-md w-full mx-4">
                <div class="p-6">
                    <div class="flex justify-between items-center mb-6">
                        <h3 class="text-xl font-semibold text-white">Selecionar Banco para Pagamento</h3>
                        <button id="close-account-selection-modal" class="text-gray-400 hover:text-white text-2xl">√ó</button>
                    </div>
                    
                    <div class="mb-4">
                        <h4 class="text-lg font-medium text-white mb-2">${bill.description || bill.name}</h4>
                        <div class="text-sm text-gray-400">
                            Per√≠odo: ${period.monthName} ${period.year} ‚Ä¢ Valor: R$ ${bill.amount.toFixed(2)}
                        </div>
                    </div>
                    
                    <div class="mb-6">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Banco com saldo suficiente:</label>
                        <select id="period-payment-account" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="">Selecione um banco</option>
                            ${accountsWithBalance.map(account => `
                                <option value="${account.id}">
                                    ${account.name} - R$ ${account.balance.toFixed(2)}
                                </option>
                            `).join('')}
                        </select>
                    </div>
                    
                    <div class="flex space-x-3">
                        <button id="confirm-period-payment-final-btn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md transition duration-200 flex-1" disabled>
                            Confirmar Pagamento
                        </button>
                        <button id="cancel-period-payment-btn" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md transition duration-200 flex-1">
                            Cancelar
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Adicionar modal ao DOM
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    const modal = document.getElementById('account-selection-modal');
    const closeBtn = document.getElementById('close-account-selection-modal');
    const cancelBtn = document.getElementById('cancel-period-payment-btn');
    const confirmBtn = document.getElementById('confirm-period-payment-final-btn');
    const accountSelect = document.getElementById('period-payment-account');
    
    // Event listeners
    closeBtn.addEventListener('click', () => {
        modal.remove();
    });
    
    cancelBtn.addEventListener('click', () => {
        modal.remove();
    });
    
    // Habilitar bot√£o quando conta for selecionada
    accountSelect.addEventListener('change', () => {
        confirmBtn.disabled = !accountSelect.value;
    });
    
    // Confirmar pagamento
    confirmBtn.addEventListener('click', async () => {
        const selectedAccountId = accountSelect.value;
        if (!selectedAccountId) {
            showWarningModal('Por favor, selecione uma conta');
            return;
        }
        
        const selectedAccount = accounts.find(a => a.id === selectedAccountId);
        if (!selectedAccount) {
            showWarningModal('Conta selecionada n√£o encontrada');
            return;
        }
        
        if (selectedAccount.balance < bill.amount) {
            showWarningModal(`Saldo insuficiente na conta ${selectedAccount.name}. Saldo: R$ ${selectedAccount.balance.toFixed(2)}`);
            return;
        }
        
        modal.remove();
        
        try {
            // Realizar pagamento
            const result = await payFixedBill(
                bill.id,
                bill.amount,
                selectedAccountId,
                true, // pagamento completo
                period.period // per√≠odo espec√≠fico
            );
            
            await showSuccessModal(`Pagamento de R$ ${bill.amount.toFixed(2)} realizado com sucesso para ${period.monthName} ${period.year}!`);
            
            // Atualizar visualiza√ß√£o
            filterBills();
            
        } catch (error) {
            showErrorModal(`Erro ao realizar pagamento: ${error.message}`);
        }
    });
    
    // Fechar ao clicar fora
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.remove();
        }
    });
}

async function handleFullPayment() {
    if (!currentBillForPayment) {
        showWarningModal('Nenhuma conta selecionada para pagamento');
        return;
    }
    
    const selectedAccountId = fullPaymentAccount.value;
    if (!selectedAccountId) {
        showWarningModal('Por favor, selecione uma conta para pagamento');
        return;
    }
    
    const selectedAccount = accounts.find(a => a.id === selectedAccountId);
    if (!selectedAccount) {
        showWarningModal('Conta selecionada n√£o encontrada');
        return;
    }
    
    // Calcular valor restante usando a nova fun√ß√£o
    const billStatus = await getFixedBillStatus(currentBillForPayment.id);
    const remainingAmount = billStatus.remainingAmount;
    
    if (remainingAmount <= 0) {
        showWarningModal('Esta conta j√° foi paga completamente');
        return;
    }
    
    if (selectedAccount.balance < remainingAmount) {
        showWarningModal(`Saldo insuficiente na conta ${selectedAccount.name}. Saldo: R$ ${selectedAccount.balance.toFixed(2)}`);
        return;
    }
    
    try {
        // Usar a nova fun√ß√£o de pagamento
        const result = await payFixedBill(
            currentBillForPayment.id, 
            remainingAmount, 
            selectedAccountId, 
            true // Pagamento completo
        );
        
        await showSuccessModal(`Pagamento completo de R$ ${remainingAmount.toFixed(2)} realizado com sucesso!`);
        
        // Fechar modal e atualizar a visualiza√ß√£o
        hideModal(fullPaymentModal);
        filterBills();
        
    } catch (error) {
        showErrorModal(`Erro ao realizar pagamento: ${error.message}`);
    }
}

function handlePartialPaymentModal(bill) {
    currentBillForPayment = bill;
    
    // Calcular valores usando a fun√ß√£o otimizada
    getFixedBillInfoOptimized(bill.id).then(billInfo => {
        // CORRE√á√ÉO: Para pagamento parcial, permitir pagar pr√≥ximo per√≠odo se atual j√° foi pago
        let targetPeriod = billInfo.periodsStatus.find(p => p.isCurrentMonth);
        
        // Se per√≠odo atual j√° foi pago completamente, usar pr√≥ximo per√≠odo dispon√≠vel
        if (!targetPeriod || targetPeriod.remainingAmount <= 0) {
            targetPeriod = billInfo.periodsStatus.find(p => p.canPay && p.remainingAmount > 0);
        }
        
        const billStatus = {
            remainingAmount: targetPeriod ? targetPeriod.remainingAmount : bill.amount,
            totalPaid: targetPeriod ? targetPeriod.totalPaid : 0
        };
        const remainingAmount = billStatus.remainingAmount;
        
        // Preencher informa√ß√µes no modal
        document.getElementById('partial-payment-bill-name').textContent = bill.description || bill.name;
        document.getElementById('partial-payment-total-amount').textContent = `R$ ${bill.amount.toFixed(2)}`;
        document.getElementById('partial-payment-paid-amount').textContent = `R$ ${billStatus.totalPaid.toFixed(2)}`;
        document.getElementById('partial-payment-remaining-amount').textContent = `R$ ${remainingAmount.toFixed(2)}`;
        
        // Configurar input de pagamento
        partialPaymentAmount.value = '';
        partialPaymentAmount.max = remainingAmount;
        partialPaymentAmount.placeholder = `M√°ximo: R$ ${remainingAmount.toFixed(2)}`;
        
        // Preencher select de contas
        partialPaymentAccount.innerHTML = '';
        accounts.forEach(account => {
            const option = document.createElement('option');
            option.value = account.id;
            option.textContent = `${account.name} (R$ ${account.balance.toFixed(2)})`;
            partialPaymentAccount.appendChild(option);
        });
        
        showModal(partialPaymentModal);
    }).catch(error => {
        showErrorModal(`Erro ao carregar dados da conta: ${error.message}`);
    });
}

async function handlePartialPayment() {
    if (!currentBillForPayment) {
        showWarningModal('Nenhuma conta selecionada para pagamento');
        return;
    }
    
    const paymentAmount = parseFloat(partialPaymentAmount.value);
    const accountId = partialPaymentAccount.value;
    
    if (!paymentAmount || paymentAmount <= 0) {
        showWarningModal('Por favor, informe um valor v√°lido para o pagamento');
        return;
    }
    
    const selectedAccount = accounts.find(acc => acc.id === accountId);
    if (!selectedAccount) {
        showWarningModal('Conta n√£o encontrada');
        return;
    }
    
    if (selectedAccount.balance < paymentAmount) {
        showWarningModal(`Saldo insuficiente na conta ${selectedAccount.name}. Saldo: R$ ${selectedAccount.balance.toFixed(2)}`);
        return;
    }
    
    // Calcular valor restante usando a fun√ß√£o otimizada (mesma do modal)
    const billInfo = await getFixedBillInfoOptimized(currentBillForPayment.id);
    
    // CORRE√á√ÉO: Para pagamento parcial, permitir pagar pr√≥ximo per√≠odo se atual j√° foi pago
    let targetPeriod = billInfo.periodsStatus.find(p => p.isCurrentMonth);
    
    // Se per√≠odo atual j√° foi pago completamente, usar pr√≥ximo per√≠odo dispon√≠vel
    if (!targetPeriod || targetPeriod.remainingAmount <= 0) {
        targetPeriod = billInfo.periodsStatus.find(p => p.canPay && p.remainingAmount > 0);
    }
    
    const remainingAmount = targetPeriod ? targetPeriod.remainingAmount : currentBillForPayment.amount;
    
    if (paymentAmount > remainingAmount) {
        showWarningModal(`Valor do pagamento (R$ ${paymentAmount.toFixed(2)}) √© maior que o valor restante (R$ ${remainingAmount.toFixed(2)})`);
        return;
    }
    
    try {
        // Usar a nova fun√ß√£o de pagamento com per√≠odo correto
        const result = await payFixedBill(
            currentBillForPayment.id, 
            paymentAmount, 
            accountId, 
            false, // Pagamento parcial
            targetPeriod ? targetPeriod.period : null // Per√≠odo espec√≠fico se for antecipado
        );
        
        await showSuccessModal(`Pagamento parcial de R$ ${paymentAmount.toFixed(2)} realizado com sucesso!`);
        
        // Fechar modal e atualizar visualiza√ß√£o
        hideModal(partialPaymentModal);
        filterBills();
        
    } catch (error) {
        showErrorModal(`Erro ao realizar pagamento: ${error.message}`);
    }
}

function updateFinancialSummary() {
    const total = accounts.reduce((sum, acc) => sum + acc.balance, 0);
    totalBalance.textContent = `R$ ${total.toFixed(2)}`;
    
    const currentMonth = new Date().getMonth();
    const currentYear = new Date().getFullYear();
    
    const monthTransactions = transactions.filter(t => {
        if (!t.date) return false;
        
        let transactionDate;
        try {
            if (t.date && typeof t.date.toDate === 'function') {
                transactionDate = t.date.toDate();
            } else if (t.date) {
                transactionDate = new Date(t.date);
            } else {
                return false;
            }
            
            if (isNaN(transactionDate.getTime())) {
                return false;
            }
            
            return transactionDate.getMonth() === currentMonth && 
                   transactionDate.getFullYear() === currentYear;
        } catch (error) {
            console.warn('Erro ao processar data da transa√ß√£o:', error);
            return false;
        }
    });
    
    const income = monthTransactions
        .filter(t => t.type === 'income')
        .reduce((sum, t) => sum + t.amount, 0);
        
    const expenses = monthTransactions
        .filter(t => t.type === 'expense')
        .reduce((sum, t) => sum + t.amount, 0);
    
    monthlyIncome.textContent = `R$ ${income.toFixed(2)}`;
    monthlyExpenses.textContent = `R$ ${expenses.toFixed(2)}`;
    
    // Atualizar tamb√©m o t√≠tulo da p√°gina com o saldo total
    document.title = `Dinah - R$ ${total.toFixed(2)}`;
}

// Handlers de formul√°rios
async function handleAccountSubmit(e) {
    e.preventDefault();
    
    const name = accountName.value.trim();
    const balance = parseFloat(accountBalance.value);
    
    if (!name) {
        showWarningModal('Nome da conta √© obrigat√≥rio');
        return;
    }
    
    if (isNaN(balance) || balance < 0) {
        showWarningModal('Saldo deve ser um n√∫mero v√°lido maior ou igual a zero');
        return;
    }
    
    try {
        const accountIdValue = accountId.value;
        
        if (accountIdValue) {
            // Editar conta existente
            await updateAccount(accountIdValue, { name, balance });
        } else {
            // Adicionar nova conta
            await addAccount(name, balance);
        }
        
        resetAccountForm();
        hideModal(accountsModal);
    } catch (error) {
        showErrorModal(`Erro: ${error.message}`);
    }
}

async function handleBillSubmit(e) {
    e.preventDefault();
    
    const name = billName.value.trim();
    const amount = parseFloat(billAmount.value);
    const dueDay = parseInt(billDueDay.value);
    const category = billCategory.value;
    const startDate = document.getElementById('bill-start-date').value;
    
    if (!name) {
        showWarningModal('Nome da conta fixa √© obrigat√≥rio');
        return;
    }
    
    if (isNaN(amount) || amount <= 0) {
        showWarningModal('Valor deve ser maior que zero');
        return;
    }
    
    if (isNaN(dueDay) || dueDay < 1 || dueDay > 31) {
        showWarningModal('Dia de vencimento deve estar entre 1 e 31');
        return;
    }
    
    if (!startDate) {
        showWarningModal('Data inicial √© obrigat√≥ria');
        return;
    }
    
    try {
        const billIdValue = billId.value;
        
        if (billIdValue) {
            // Editar conta fixa existente
            await updateFixedBill(billIdValue, { name, amount, dueDay, category, startDate });
        } else {
            // Adicionar nova conta fixa
            await addFixedBill({ name, amount, dueDay, category, startDate });
        }
        
        resetBillForm();
        hideModal(billsModal);
    } catch (error) {
        showErrorModal(`Erro: ${error.message}`);
    }
}

// Fun√ß√µes de edi√ß√£o
function editAccount(account) {
    accountId.value = account.id;
    accountName.value = account.name;
    accountBalance.value = account.balance;
    
    document.getElementById('account-form-title').textContent = 'Editar Conta';
    document.getElementById('save-account-btn').textContent = 'Atualizar';
}

function editBill(bill) {
    billId.value = bill.id;
    billName.value = bill.description || bill.name;
    billAmount.value = bill.amount;
    billDueDay.value = bill.dueDay;
    billCategory.value = bill.category || 'outros';
    
    // Definir data inicial se dispon√≠vel
    const startDateInput = document.getElementById('bill-start-date');
    if (bill.initialDate) {
        const initialDate = bill.initialDate.toDate ? bill.initialDate.toDate() : new Date(bill.initialDate);
        startDateInput.value = initialDate.toISOString().split('T')[0];
    } else {
        startDateInput.value = new Date().toISOString().split('T')[0];
    }
    
    document.getElementById('bill-form-title').textContent = 'Editar Conta Fixa';
    document.getElementById('save-bill-btn').textContent = 'Atualizar';
}

// Fun√ß√µes de reset
function resetAccountForm() {
    accountForm.reset();
    accountId.value = '';
    document.getElementById('account-form-title').textContent = 'Adicionar Nova Conta';
    document.getElementById('save-account-btn').textContent = 'Salvar';
}

function resetBillForm() {
    billForm.reset();
    billId.value = '';
    document.getElementById('bill-form-title').textContent = 'Adicionar Nova Conta Fixa';
    document.getElementById('save-bill-btn').textContent = 'Salvar';
    
    // Definir data atual como padr√£o
    document.getElementById('bill-start-date').value = new Date().toISOString().split('T')[0];
}

// Fun√ß√µes de confirma√ß√£o
let confirmCallback = null;

function showConfirmModal(title, message, callback) {
    document.getElementById('confirm-title').textContent = title;
    document.getElementById('confirm-message').textContent = message;
    confirmCallback = callback;
    showModal(confirmModal);
}

async function handleConfirmDelete() {
    if (confirmCallback) {
        try {
            await confirmCallback();
            hideModal(confirmModal);
        } catch (error) {
            showErrorModal(`Erro: ${error.message}`);
        }
    }
}

// Fun√ß√µes de modal
function showModal(modal) {
    modal.classList.remove('hidden');
}

function hideModal(modal) {
    modal.classList.add('hidden');
}

// Fun√ß√µes utilit√°rias
function formatDate(date) {
    if (!date) return 'Data n√£o dispon√≠vel';
    
    try {
        const dateObj = date.toDate ? date.toDate() : new Date(date);
        return dateObj.toLocaleDateString('pt-BR');
    } catch (error) {
        return 'Data inv√°lida';
    }
}

function getTransactionTypeLabel(type) {
    const labels = {
        'income': 'Receita',
        'expense': 'Despesa',
        'transfer': 'Transfer√™ncia',
        'transfer_in': 'Transfer√™ncia Recebida',
        'transfer_out': 'Transfer√™ncia Enviada'
    };
    return labels[type] || type;
}

// Fun√ß√µes para contas fixas
function calculateBillStatus(bill) {
    const today = new Date();
    const currentDay = today.getDate();
    const currentMonth = today.getMonth();
    const currentYear = today.getFullYear();
    
    // Calcular data de vencimento para o m√™s atual
    const dueDate = new Date(currentYear, currentMonth, bill.dueDay);
    
    // Se o dia de vencimento j√° passou este m√™s, calcular para o pr√≥ximo m√™s
    if (currentDay > bill.dueDay) {
        dueDate.setMonth(currentMonth + 1);
    }
    
    // Calcular dias at√© o vencimento
    const daysUntilDue = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
    
    // Verificar se j√° foi paga (baseado em transa√ß√µes)
    const billTransactions = transactions.filter(t => 
        t.billId === bill.id && 
        t.type === 'expense' &&
        (t.isPartialPayment || t.isBillPayment)
    );
    
    const totalPaid = billTransactions.reduce((sum, t) => sum + t.amount, 0);
    const remainingAmount = bill.amount - totalPaid;
    
    if (remainingAmount <= 0) {
        return 'paid';
    } else if (totalPaid > 0) {
        return 'partial';
    } else if (daysUntilDue < 0) {
        return 'overdue';
    } else if (daysUntilDue === 0) {
        return 'due-today';
    } else if (daysUntilDue <= 7) {
        return 'due-soon';
    } else {
        return 'pending';
    }
}

function getStatusClass(status) {
    const classes = {
        'paid': 'text-green-400',
        'partial': 'text-yellow-400',
        'pending': 'text-blue-400',
        'overdue': 'text-red-400',
        'due-soon': 'text-orange-400',
        'due-today': 'text-orange-500'
    };
    return classes[status] || 'text-gray-400';
}

function getStatusText(status) {
    const texts = {
        'paid': 'Paga',
        'partial': 'Paga Parcial',
        'pending': 'Pendente',
        'overdue': 'Vencida',
        'due-soon': 'Quase Vencendo',
        'due-today': 'Vence Hoje'
    };
    return texts[status] || 'Desconhecido';
}

function addChatMessage(sender, message, buttons = null) {
    const messageElement = document.createElement('div');
    messageElement.className = `chat-message ${sender}`;
    
    // Criar container para a mensagem
    const messageContainer = document.createElement('div');
    messageContainer.innerHTML = message.replace(/\n/g, '<br>');
    messageElement.appendChild(messageContainer);
    
    // Adicionar bot√µes se existirem
    if (buttons && Array.isArray(buttons)) {
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'chat-buttons';
        buttonsContainer.style.marginTop = '10px';
        buttonsContainer.style.display = 'flex';
        buttonsContainer.style.gap = '8px';
        buttonsContainer.style.flexWrap = 'wrap';
        
        buttons.forEach(button => {
            const buttonElement = document.createElement('button');
            buttonElement.textContent = button.text;
            buttonElement.className = `chat-button ${button.style || 'primary'}`;
            buttonElement.disabled = button.disabled || false;
            
            // Estilos dos bot√µes
            buttonElement.style.padding = '6px 12px';
            buttonElement.style.border = 'none';
            buttonElement.style.borderRadius = '4px';
            buttonElement.style.cursor = button.disabled ? 'not-allowed' : 'pointer';
            buttonElement.style.fontSize = '12px';
            buttonElement.style.fontWeight = '500';
            buttonElement.style.transition = 'all 0.2s ease';
            buttonElement.style.minWidth = '120px';
            buttonElement.style.maxWidth = '150px';
            buttonElement.style.flex = '1';
            
            // Cores baseadas no estilo
            if (button.style === 'success') {
                buttonElement.style.backgroundColor = '#10b981';
                buttonElement.style.color = 'white';
            } else if (button.style === 'danger') {
                buttonElement.style.backgroundColor = '#ef4444';
                buttonElement.style.color = 'white';
            } else if (button.style === 'primary') {
                buttonElement.style.backgroundColor = '#3b82f6';
                buttonElement.style.color = 'white';
            } else {
                buttonElement.style.backgroundColor = '#6b7280';
                buttonElement.style.color = 'white';
            }
            
            // Efeito hover
            if (!button.disabled) {
                buttonElement.addEventListener('mouseenter', () => {
                    buttonElement.style.opacity = '0.8';
                    buttonElement.style.transform = 'translateY(-1px)';
                });
                buttonElement.addEventListener('mouseleave', () => {
                    buttonElement.style.opacity = '1';
                    buttonElement.style.transform = 'translateY(0)';
                });
            }
            
            // Evento de clique
            buttonElement.addEventListener('click', () => {
                if (!button.disabled) {
                    // Ocultar todos os bot√µes da mensagem
                    const allButtons = buttonsContainer.querySelectorAll('button');
                    allButtons.forEach(btn => {
                        btn.style.opacity = '0.5';
                        btn.style.pointerEvents = 'none';
                        btn.style.transform = 'scale(0.95)';
                    });
                    
                    // Enviar o valor do bot√£o como mensagem ap√≥s um pequeno delay
                    setTimeout(() => {
                        chatInput.value = button.value;
                        handleSendMessage();
                    }, 200);
                }
            });
            
            buttonsContainer.appendChild(buttonElement);
        });
        
        messageElement.appendChild(buttonsContainer);
    }
    
    chatMessages.appendChild(messageElement);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

// Fun√ß√£o auxiliar para obter nome da categoria
function getCategoryName(category) {
    const categoryNames = {
        'moradia': 'Moradia',
        'energia': 'Energia',
        'agua': '√Ågua',
        'internet': 'Internet',
        'telefone': 'Telefone',
        'gas': 'G√°s',
        'condominio': 'Condom√≠nio',
        'seguro': 'Seguro',
        'escola': 'Educa√ß√£o',
        'cartao': 'Cart√£o de Cr√©dito',
        'streaming': 'Streaming',
        'academia': 'Academia',
        'outros': 'Outros'
    };
    return categoryNames[category] || 'Outros';
}

// Fun√ß√£o de debug para investigar auto-expans√£o
async function debugAutoExpansion(billId) {
    try {
        console.log('üîç === DEBUG AUTO-EXPANS√ÉO ===');
        
        // Buscar dados da conta fixa
        const billRef = doc(db, 'users', auth.currentUser.uid, 'recurring_bills', billId);
        const billDoc = await getDoc(billRef);
        const billData = billDoc.data();
        
        console.log('üìä Dados da conta fixa:', {
            description: billData.description,
            autoExpansionEnabled: billData.autoExpansionEnabled,
            totalPeriodsGenerated: billData.totalPeriodsGenerated,
            initialDate: billData.initialDate?.toDate ? billData.initialDate.toDate() : new Date(billData.initialDate),
            dueDay: billData.dueDay
        });
        
        const initialDate = billData.initialDate?.toDate ? billData.initialDate.toDate() : new Date(billData.initialDate);
        const totalPeriods = billData.totalPeriodsGenerated || 12;
        const periods = calculateAllPeriodsFromInitial(initialDate, billData.dueDay, totalPeriods, false);
        
        console.log('üìã Per√≠odos calculados:', periods.map(p => ({
            period: p.period,
            monthName: p.monthName,
            year: p.year
        })));
        
        // Verificar pagamentos de cada per√≠odo
        const paidPeriods = [];
        const unpaidPeriods = [];
        
        for (let i = 0; i < periods.length; i++) {
            const period = periods[i];
            const periodStatus = await getMonthPaymentStatus(billId, period.year, period.month);
            
            if (periodStatus.isFullyPaid) {
                paidPeriods.push({
                    index: i,
                    period: period.period,
                    monthName: period.monthName,
                    year: period.year
                });
            } else {
                unpaidPeriods.push({
                    index: i,
                    period: period.period,
                    monthName: period.monthName,
                    year: period.year,
                    remainingAmount: periodStatus.remainingAmount
                });
            }
        }
        
        console.log('‚úÖ Per√≠odos pagos:', paidPeriods);
        console.log('‚è≥ Per√≠odos n√£o pagos:', unpaidPeriods);
        
        // Calcular per√≠odos restantes
        const lastPaidIndex = paidPeriods.length > 0 ? Math.max(...paidPeriods.map(p => p.index)) : -1;
        const periodsRemaining = periods.length - (lastPaidIndex + 1);
        
        console.log('üìä An√°lise:', {
            totalPeriods: periods.length,
            paidPeriods: paidPeriods.length,
            unpaidPeriods: unpaidPeriods.length,
            lastPaidIndex: lastPaidIndex,
            periodsRemaining: periodsRemaining,
            shouldExpand: periodsRemaining <= 5
        });
        
        return {
            billData,
            periods,
            paidPeriods,
            unpaidPeriods,
            periodsRemaining,
            shouldExpand: periodsRemaining <= 5
        };
        
    } catch (error) {
        console.error('‚ùå Erro no debug:', error);
        throw error;
    }
}

async function checkAndExpandAllBills() {
    if (!fixedBills || fixedBills.length === 0) return;
    
    try {
        let expandedCount = 0;
        const expansionResults = [];
        
        // Verificar cada conta fixa individualmente
        for (const bill of fixedBills) {
            try {
                const result = await checkAndExpandPeriods(bill.id);
                if (result.expanded) {
                    expandedCount++;
                    expansionResults.push({
                        billId: bill.id,
                        billName: bill.description,
                        expanded: true,
                        message: result.message,
                        newTotalPeriods: result.newTotalPeriods
                    });
                }
            } catch (error) {
                console.warn(`Erro ao verificar expans√£o da conta ${bill.description}:`, error);
            }
        }
        
        // Se houve expans√µes, mostrar notifica√ß√£o
        if (expandedCount > 0) {
            const message = expandedCount === 1 
                ? `‚úÖ ${expansionResults[0].billName}: ${expansionResults[0].message}`
                : `‚úÖ ${expandedCount} contas fixas foram expandidas automaticamente!`;
            
            await showSuccessModal(message);
            
            // Atualizar a visualiza√ß√£o
            renderFixedBills();
            renderBillsView();
        }
        
        return expansionResults;
        
    } catch (error) {
        console.error('Erro ao verificar expans√£o de contas fixas:', error);
        throw error;
    }
}

// Fun√ß√£o para mostrar hist√≥rico de pagamentos
async function showPaymentHistory(billId) {
    try {
        // Usar fun√ß√£o otimizada para obter hist√≥rico
        const paymentHistory = await getFixedBillPaymentHistoryOptimized(billId, 12);
        
        // Buscar dados b√°sicos da conta fixa
        const billRef = doc(db, 'users', auth.currentUser.uid, 'recurring_bills', billId);
        const billDoc = await getDoc(billRef);
        
        if (!billDoc.exists()) {
            throw new Error('Conta fixa n√£o encontrada');
        }
        
        const billData = billDoc.data();
        
        // Preencher conte√∫do do modal
        const content = document.getElementById('payment-history-content');
        // Renderizar hist√≥rico otimizado
        const historyHtml = paymentHistory.map(period => `
            <div class="bg-gray-700 rounded-lg p-4 mb-3">
                <div class="flex justify-between items-center mb-2">
                    <h5 class="font-medium text-white">${period.monthName} ${period.period.split('-')[0]}</h5>
                    <span class="text-sm ${period.totalPaid >= billData.amount ? 'text-green-400' : 'text-yellow-400'}">
                        ${period.totalPaid >= billData.amount ? '‚úÖ Pago' : '‚ö†Ô∏è Parcial'}
                    </span>
                </div>
                <div class="grid grid-cols-2 gap-4 text-sm">
                    <div>
                        <span class="text-gray-400">Valor:</span>
                        <span class="text-white">R$ ${billData.amount.toFixed(2)}</span>
                    </div>
                    <div>
                        <span class="text-gray-400">Pago:</span>
                        <span class="text-green-400">R$ ${period.totalPaid.toFixed(2)}</span>
                    </div>
                    <div>
                        <span class="text-gray-400">Restante:</span>
                        <span class="text-red-400">R$ ${(billData.amount - period.totalPaid).toFixed(2)}</span>
                    </div>
                    <div>
                        <span class="text-gray-400">Pagamentos:</span>
                        <span class="text-blue-400">${period.paymentCount}</span>
                    </div>
                </div>
                ${period.payments.length > 0 ? `
                    <div class="mt-3 pt-3 border-t border-gray-600">
                        <div class="text-xs text-gray-400 mb-2">Detalhes dos pagamentos:</div>
                        ${period.payments.map(payment => `
                            <div class="text-xs text-gray-300 mb-1">
                                ‚Ä¢ R$ ${payment.amount.toFixed(2)} - ${new Date(payment.date?.toDate ? payment.date.toDate() : payment.date).toLocaleDateString('pt-BR')}
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
            </div>
        `).join('');
        
        content.innerHTML = `
            <div class="mb-6">
                <h4 class="text-lg font-semibold text-white mb-2">${billData.description}</h4>
                <div class="text-sm text-gray-400">
                    Valor: R$ ${billData.amount.toFixed(2)} ‚Ä¢ Vencimento: dia ${billData.dueDay}
                </div>
            </div>
            
            <div class="space-y-3">
                <h5 class="text-md font-semibold text-white mb-3">üìä Hist√≥rico de Pagamentos</h5>
                ${historyHtml || '<div class="text-center py-8 text-gray-400">Nenhum pagamento encontrado</div>'}
            </div>
        `;
        
        // Mostrar modal
        const paymentHistoryModal = document.getElementById('payment-history-modal');
        paymentHistoryModal.classList.remove('hidden');
        paymentHistoryModal.dataset.currentBillId = billId;
        
    } catch (error) {
        console.error('Erro ao carregar hist√≥rico:', error);
        showErrorModal('Erro ao carregar hist√≥rico de pagamentos');
    }
}

// Controle de telas
function showLoginScreen() {
    loginScreen.classList.remove('hidden');
    appScreen.classList.add('hidden');
}

function showAppScreen() {
    loginScreen.classList.add('hidden');
    appScreen.classList.remove('hidden');
}

// Utilit√°rios
function showAuthError(message) {
    authError.textContent = message;
    authError.classList.remove('hidden');
}

function hideAuthError() {
    authError.classList.add('hidden');
}

// Fun√ß√£o para atualizar interface ap√≥s estorno de transa√ß√£o
async function updateInterfaceAfterRefund(transactionId) {
    try {
        console.log('üîÑ Atualizando interface ap√≥s estorno...');
        
        // Remover transa√ß√£o do cache local
        allLoadedTransactions = allLoadedTransactions.filter(t => t.id !== transactionId);
        filteredTransactions = filteredTransactions.filter(t => t.id !== transactionId);
        
        // Remover das transa√ß√µes recentes tamb√©m
        transactions = transactions.filter(t => t.id !== transactionId);
        
        // Atualizar interface das transa√ß√µes recentes
        renderRecentTransactions();
        
        // Se o modal de transa√ß√µes estiver aberto, atualizar tamb√©m
        if (!transactionsModal.classList.contains('hidden')) {
            renderTransactionsOptimized();
        }
        
        // Se o modal de hist√≥rico de pagamentos estiver aberto, atualizar tamb√©m
        const paymentHistoryModal = document.getElementById('payment-history-modal');
        if (paymentHistoryModal && !paymentHistoryModal.classList.contains('hidden')) {
            // Recarregar hist√≥rico se estiver aberto
            const currentBillId = paymentHistoryModal.dataset.currentBillId;
            if (currentBillId) {
                await showPaymentHistory(currentBillId);
            }
        }
        
        // Atualizar resumo financeiro
        updateFinancialSummary();
        
        console.log('‚úÖ Interface atualizada ap√≥s estorno');
        
    } catch (error) {
        console.error('Erro ao atualizar interface ap√≥s estorno:', error);
    }
}

// Fun√ß√£o para estornar transa√ß√£o (deve ser global para o onclick)
window.handleRefund = async function(transactionId) {
    try {
        // Verificar se a transa√ß√£o ainda existe no cache local
        const transactionExists = allLoadedTransactions.some(t => t.id === transactionId) || 
                                 transactions.some(t => t.id === transactionId);
        
        if (!transactionExists) {
            showWarningModal('Esta transa√ß√£o j√° foi estornada ou n√£o existe mais.');
            return;
        }
        
        // Mostrar modal de confirma√ß√£o
        showConfirmModal(
            'Confirmar Estorno',
            'Tem certeza que deseja estornar esta transa√ß√£o? Esta a√ß√£o ir√° reverter o saldo da conta e remover a transa√ß√£o do hist√≥rico.',
            async () => {
                try {
                    const refundResult = await refundTransaction(transactionId);
                    showSuccessModal(refundResult.message);
                    
                    // Atualizar interface imediatamente ap√≥s estorno
                    await updateInterfaceAfterRefund(transactionId);
                    
                } catch (error) {
                    showErrorModal(`Erro ao estornar transa√ß√£o: ${error.message}`);
                }
            }
        );
    } catch (error) {
        showErrorModal(`Erro ao processar estorno: ${error.message}`);
    }
};

// Fun√ß√£o global para carregar mais transa√ß√µes
window.loadMoreTransactions = async function() {
    await loadMoreTransactionsInternal();
};

// Fun√ß√£o de debug para investigar auto-expans√£o
window.debugAutoExpansion = debugAutoExpansion;

// Fun√ß√£o para estornar transa√ß√£o (vers√£o interna)
async function handleRefundInternal(transactionId) {
    try {
        const result = await showConfirmModal(
            'Confirmar Estorno',
            'Tem certeza que deseja estornar esta transa√ß√£o? Esta a√ß√£o ir√° reverter o saldo da conta e remover a transa√ß√£o do hist√≥rico.',
            async () => {
                const refundResult = await refundTransaction(transactionId);
                showSuccessModal(refundResult.message);
                
                // Atualizar interface imediatamente ap√≥s estorno
                await updateInterfaceAfterRefund(transactionId);
            }
        );
    } catch (error) {
        showErrorModal(`Erro ao estornar transa√ß√£o: ${error.message}`);
    }
}

// Teste para verificar se tudo est√° funcionando
console.log('üîß Testando sistema de estorno...');

// Verificar se a fun√ß√£o est√° dispon√≠vel globalmente
if (typeof window.handleRefund === 'function') {
} else {
    console.log('‚ùå Fun√ß√£o handleRefund N√ÉO est√° dispon√≠vel globalmente');
}

// Verificar se a fun√ß√£o refundTransaction est√° sendo importada
if (typeof refundTransaction === 'function') {
} else {
    console.log('‚ùå Fun√ß√£o refundTransaction N√ÉO est√° dispon√≠vel');
}

// Verificar se a fun√ß√£o showConfirmModal est√° dispon√≠vel
if (typeof showConfirmModal === 'function') {
} else {
    console.log('‚ùå Fun√ß√£o showConfirmModal N√ÉO est√° dispon√≠vel');
}

console.log('üéâ Sistema de estorno testado com sucesso!');
